// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data;
using System.Net;
using System.Net.NetworkInformation;
using System.Text.Json;
using Microsoft.EntityFrameworkCore.Design.Internal;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Scaffolding.TestModel.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Design.Internal;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.ValueGeneration.Internal;
using NetTopologySuite;
using NetTopologySuite.Geometries;
using Newtonsoft.Json.Linq;
using static Microsoft.EntityFrameworkCore.Migrations.Design.CSharpMigrationsGeneratorTest;
using static Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest;
using IdentityUser = Microsoft.EntityFrameworkCore.TestModels.AspNetIdentity.IdentityUser;
using Index = Microsoft.EntityFrameworkCore.Scaffolding.Internal.Index;

public class GlobalNamespaceContext : ContextBase
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity(
            "1", e =>
            {
                e.Property<int>("Id");
                e.HasKey("Id");
            });
    }
}

namespace Microsoft.EntityFrameworkCore.Scaffolding.Internal
{
    public class CSharpRuntimeModelCodeGeneratorTest
    {
        [ConditionalFact]
        public void Self_referential_property()
            => Test(
                new SelfReferentialDbContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    Assert.Single(model.GetEntityTypes());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                }
            );

        [ConditionalFact]
        public void Empty_model()
            => Test(
                new EmptyContext(),
                new CompiledModelCodeGenerationOptions(),
                code =>
                    Assert.Collection(
                        code,
                        c => AssertFileContents(
                            "EmptyContextModel.cs",
                            """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.EmptyContext))]
    public partial class EmptyContextModel : RuntimeModel
    {
        private static readonly bool _useOldBehavior31751 =
            System.AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31751", out var enabled31751) && enabled31751;

        static EmptyContextModel()
        {
            var model = new EmptyContextModel();

            if (_useOldBehavior31751)
            {
                model.Initialize();
            }
            else
            {
                var thread = new System.Threading.Thread(RunInitialization, 10 * 1024 * 1024);
                thread.Start();
                thread.Join();

                void RunInitialization()
                {
                    model.Initialize();
                }
            }

            model.Customize();
            _instance = model;
        }

        private static EmptyContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""",
                            c),
                        c => AssertFileContents(
                            "EmptyContextModelBuilder.cs",
                            """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class EmptyContextModel
    {
        partial void Initialize()
        {
        }
    }
}
""",
                            c)),
                model =>
                {
                    Assert.Empty(model.GetEntityTypes());
                    Assert.Same(model, model.FindRuntimeAnnotationValue("ReadOnlyModel"));
                });

        public class EmptyContext : ContextBase
        {
        }

        [ConditionalFact]
        public void Global_namespace_works()
            => Test(
                new GlobalNamespaceContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = string.Empty },
                code =>
                {
                    Assert.All(code, f => Assert.DoesNotContain("namespace ", f.Code));
                },
                model =>
                {
                    Assert.NotNull(model.FindEntityType("1"));
                });

        [ConditionalFact]
        public void Throws_for_constructor_binding()
            => Test(
                new ConstructorBindingContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelConstructorBinding("Lazy", "Customize()", "LazyEntityType"));

        public class ConstructorBindingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "Lazy", e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        ((EntityType)e.Metadata).ConstructorBinding = new ConstructorBinding(
                            typeof(object).GetConstructor(Type.EmptyTypes)!,
                            Array.Empty<ParameterBinding>());
                    });
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => base.OnConfiguring(options.UseLazyLoadingProxies());
        }

        [ConditionalFact]
        public void Manual_lazy_loading()
            => Test(
                new LazyLoadingContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    var lazyConstructorEntity = model.FindEntityType(typeof(LazyConstructorEntity));
                    var lazyParameterBinding = lazyConstructorEntity!.ConstructorBinding!.ParameterBindings.Single();
                    Assert.Equal(typeof(ILazyLoader), lazyParameterBinding.ParameterType);

                    var lazyPropertyEntity = model.FindEntityType(typeof(LazyPropertyEntity));
                    var lazyServiceProperty = lazyPropertyEntity!.GetServiceProperties().Single();
                    Assert.Equal(typeof(ILazyLoader), lazyServiceProperty.ClrType);

                    var lazyPropertyDelegateEntity = model.FindEntityType(typeof(LazyPropertyDelegateEntity));
                    Assert.Equal(2, lazyPropertyDelegateEntity!.GetServiceProperties().Count());
                    Assert.Contains(lazyPropertyDelegateEntity!.GetServiceProperties(), p => p.ClrType == typeof(ILazyLoader));
                    Assert.Contains(lazyPropertyDelegateEntity!.GetServiceProperties(), p => p.ClrType == typeof(Action<object, string>));
                });

        public class LazyLoadingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<LazyConstructorEntity>();

                modelBuilder.Entity<LazyPropertyDelegateEntity>(
                    b =>
                    {
                        var serviceProperty = (ServiceProperty)b.Metadata.AddServiceProperty(
                            typeof(LazyPropertyDelegateEntity).GetAnyProperty("LoaderState")!,
                            typeof(ILazyLoader));

                        serviceProperty.SetParameterBinding(
                            new DependencyInjectionParameterBinding(typeof(object), typeof(ILazyLoader), serviceProperty),
                            ConfigurationSource.Explicit);
                    });
            }
        }

        public class LazyConstructorEntity
        {
            private readonly ILazyLoader _loader;

            public LazyConstructorEntity(ILazyLoader loader)
            {
                _loader = loader;
            }

            public int Id { get; set; }

            public LazyPropertyEntity LazyPropertyEntity { get; set; }
            public LazyPropertyDelegateEntity LazyPropertyDelegateEntity { get; set; }
        }

        public class LazyPropertyEntity
        {
            public ILazyLoader Loader { get; set; }

            public int Id { get; set; }
            public int LazyConstructorEntityId { get; set; }

            public LazyConstructorEntity LazyConstructorEntity { get; set; }
        }

        public class LazyPropertyDelegateEntity
        {
            public object LoaderState { get; set; }
            private Action<object, string> LazyLoader { get; set; }

            public int Id { get; set; }
            public int LazyConstructorEntityId { get; set; }

            public LazyConstructorEntity LazyConstructorEntity { get; set; }
        }

        [ConditionalFact]
        public void Lazy_loading_proxies()
            => Test(
                new LazyLoadingProxiesContext(),
                new CompiledModelCodeGenerationOptions(),
                assertModel: model =>
                {
                    Assert.Equal(
                        typeof(ILazyLoader), model.FindEntityType(typeof(LazyProxiesEntity1))!.GetServiceProperties().Single().ClrType);
                    Assert.Equal(
                        typeof(ILazyLoader), model.FindEntityType(typeof(LazyProxiesEntity1))!.GetServiceProperties().Single().ClrType);
                });

        public class LazyLoadingProxiesContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<LazyProxiesEntity1>();
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => base.OnConfiguring(options.UseLazyLoadingProxies());
        }

        public class LazyProxiesEntity1
        {
            public int Id { get; set; }

            public virtual LazyProxiesEntity2 ReferenceNavigation { get; set; }
        }

        public class LazyProxiesEntity2
        {
            public ILazyLoader Loader { get; set; }

            public int Id { get; set; }
            public virtual ICollection<LazyProxiesEntity1> CollectionNavigation { get; set; }
        }

        [ConditionalFact]
        public void Throws_for_query_filter()
            => Test(
                new QueryFilterContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelQueryFilter("QueryFilter"));

        public class QueryFilterContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "QueryFilter", e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        e.HasQueryFilter((Expression<Func<Dictionary<string, object>, bool>>)(e => e != null));
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_defining_query()
            => Test(
                new DefiningQueryContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelDefiningQuery("object"));

        public class DefiningQueryContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<object>(
                    e =>
                    {
                        e.Property<int>("Id");
                        e.HasKey("Id");
                        e.Metadata.SetInMemoryQuery(() => (IQueryable<object>)Set<object>());
                    });
            }
        }

        [ConditionalFact]
        public void Throws_for_value_generator()
            => Test(
                new ValueGeneratorContext(),
                new CompiledModelCodeGenerationOptions(),
                expectedExceptionMessage: DesignStrings.CompiledModelValueGenerator(
                    "MyEntity", "Id", nameof(PropertyBuilder.HasValueGeneratorFactory)));

        public class ValueGeneratorContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasValueGenerator((p, e) => null);
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Custom_value_converter()
            => Test(
                new ValueConverterContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ValueConverterContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ValueConverterContext))]
    public partial class ValueConverterContextModel : RuntimeModel
    {
        private static readonly bool _useOldBehavior31751 =
            System.AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31751", out var enabled31751) && enabled31751;

        static ValueConverterContextModel()
        {
            var model = new ValueConverterContextModel();

            if (_useOldBehavior31751)
            {
                model.Initialize();
            }
            else
            {
                var thread = new System.Threading.Thread(RunInitialization, 10 * 1024 * 1024);
                thread.Start();
                thread.Join();

                void RunInitialization()
                {
                    model.Initialize();
                }
            }

            model.Customize();
            _instance = model;
        }

        private static ValueConverterContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ValueConverterContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ValueConverterContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""", c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                converter: new ValueConverter<int, int>(
                    (int i) => i,
                    (int i) => i),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<int, int>(
                        (int i) => i,
                        (int i) => i)));

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    var converter = entityType.FindProperty("Id").GetTypeMapping().Converter;
                    Assert.Equal(1, converter.ConvertToProvider(1));
                });

        public class ValueConverterContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(i => i, i => i);
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Custom_value_comparer()
            => Test(
                new ValueComparerContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ValueComparerContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ValueComparerContext))]
    public partial class ValueComparerContextModel : RuntimeModel
    {
        private static readonly bool _useOldBehavior31751 =
            System.AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31751", out var enabled31751) && enabled31751;

        static ValueComparerContextModel()
        {
            var model = new ValueComparerContextModel();

            if (_useOldBehavior31751)
            {
                model.Initialize();
            }
            else
            {
                var thread = new System.Threading.Thread(RunInitialization, 10 * 1024 * 1024);
                thread.Start();
                thread.Join();

                void RunInitialization()
                {
                    model.Initialize();
                }
            }

            model.Customize();
            _instance = model;
        }

        private static ValueComparerContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ValueComparerContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ValueComparerContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""", c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                providerPropertyType: typeof(int));
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                keyComparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                providerValueComparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    Assert.True(
                        entityType.FindProperty("Id").GetValueComparer().SnapshotExpression
                            is Expression<Func<int, int>> lambda
                        && lambda.Body is ConstantExpression constant
                        && ((int)constant.Value) == 1);
                });

        public class ValueComparerContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(typeof(int), new FakeValueComparer());
                        e.HasKey("Id");
                    });
            }
        }

        private class FakeValueComparer : ValueComparer<int>
        {
            public FakeValueComparer()
                : base((l, r) => false, v => 0, v => 1)
            {
            }

            public override Type Type { get; } = typeof(int);

            public override bool Equals(object left, object right)
                => throw new NotImplementedException();

            public override int GetHashCode(object instance)
                => throw new NotImplementedException();

            public override object Snapshot(object instance)
                => throw new NotImplementedException();
        }

        [ConditionalFact]
        public void Custom_provider_value_comparer()
            => Test(
                new ProviderValueComparerContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "ProviderValueComparerContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.ProviderValueComparerContext))]
    public partial class ProviderValueComparerContextModel : RuntimeModel
    {
        private static readonly bool _useOldBehavior31751 =
            System.AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31751", out var enabled31751) && enabled31751;

        static ProviderValueComparerContextModel()
        {
            var model = new ProviderValueComparerContextModel();

            if (_useOldBehavior31751)
            {
                model.Initialize();
            }
            else
            {
                var thread = new System.Threading.Thread(RunInitialization, 10 * 1024 * 1024);
                thread.Start();
                thread.Join();

                void RunInitialization()
                {
                    model.Initialize();
                }
            }

            model.Customize();
            _instance = model;
        }

        private static ProviderValueComparerContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "ProviderValueComparerContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class ProviderValueComparerContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""", c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                providerPropertyType: typeof(int));
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int l, int r) => false,
                    (int v) => 0,
                    (int v) => 1),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    Assert.True(
                        entityType.FindProperty("Id").GetProviderValueComparer().SnapshotExpression
                            is Expression<Func<int, int>> lambda
                        && lambda.Body is ConstantExpression constant
                        && ((int)constant.Value) == 1);
                });

        public class ProviderValueComparerContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").HasConversion(typeof(int), null, new FakeValueComparer());
                        e.HasKey("Id");
                    });
            }
        }

        [ConditionalFact]
        public void Custom_type_mapping()
            => Test(
                new TypeMappingContext(),
                new CompiledModelCodeGenerationOptions(),
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "TypeMappingContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.TypeMappingContext))]
    public partial class TypeMappingContextModel : RuntimeModel
    {
        private static readonly bool _useOldBehavior31751 =
            System.AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31751", out var enabled31751) && enabled31751;

        static TypeMappingContextModel()
        {
            var model = new TypeMappingContextModel();

            if (_useOldBehavior31751)
            {
                model.Initialize();
            }
            else
            {
                var thread = new System.Threading.Thread(RunInitialization, 10 * 1024 * 1024);
                thread.Start();
                thread.Join();

                void RunInitialization()
                {
                    model.Initialize();
                }
            }

            model.Customize();
            _instance = model;
        }

        private static TypeMappingContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""",
                        c),
                    c => AssertFileContents(
                        "TypeMappingContextModelBuilder.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    public partial class TypeMappingContextModel
    {
        partial void Initialize()
        {
            var myEntity = MyEntityEntityType.Create(this);

            MyEntityEntityType.CreateAnnotations(myEntity);

        }
    }
}
""",
                        c),
                    c => AssertFileContents(
                        "MyEntityEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.Json;

#pragma warning disable 219, 612, 618
#nullable disable

namespace TestNamespace
{
    internal partial class MyEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "MyEntity",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                clrType: typeof(int),
                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""",
                        c)),
                model =>
                {
                    var entityType = model.GetEntityTypes().Single();

                    var typeMapping = entityType.FindProperty("Id").FindTypeMapping()!;
                    Assert.IsType<InMemoryTypeMapping>(typeMapping);
                    Assert.IsType<JsonInt32ReaderWriter>(typeMapping.JsonValueReaderWriter);
                });

        public class TypeMappingContext : ContextBase
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity(
                    "MyEntity", e =>
                    {
                        e.Property<int>("Id").Metadata.SetTypeMapping(
                            new InMemoryTypeMapping(typeof(int), jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
                        e.HasKey("Id");
                    });
            }
        }

        public class CustomValueComparer<T> : ValueComparer<T>
        {
            public CustomValueComparer()
                : base(false)
            {
            }
        }

        public abstract class AbstractBase
        {
            public int Id { get; set; }
        }

        public enum AnEnum
        {
            A = 1,
            B,
        }

        public enum AFlagsEnum
        {
            A = 1,
            B = 2,
            C = 4,
        }

        public sealed class MyJsonGuidReaderWriter : JsonValueReaderWriter<Guid>
        {
            public override Guid FromJsonTyped(ref Utf8JsonReaderManager manager, object existingObject = null)
                => manager.CurrentReader.GetGuid();

            public override void ToJsonTyped(Utf8JsonWriter writer, Guid value)
                => writer.WriteStringValue(value);
        }

        public class ManyTypes
        {
            public ManyTypesId Id { get; set; }
            public bool Bool { get; set; }
            public byte UInt8 { get; set; }
            public ushort UInt16 { get; set; }
            public uint UInt32 { get; set; }
            public ulong UInt64 { get; set; }
            public sbyte Int8 { get; set; }
            public short Int16 { get; set; }
            public int Int32 { get; set; }
            public long Int64 { get; set; }
            public char Char { get; set; }
            public decimal Decimal { get; set; }
            public double Double { get; set; }
            public float Float { get; set; }
            public Guid Guid { get; set; }
            public DateTime DateTime { get; set; }
            public DateOnly DateOnly { get; set; }
            public TimeOnly TimeOnly { get; set; }
            public TimeSpan TimeSpan { get; set; }
            public string String { get; set; }
            public byte[] Bytes { get; set; }
            public Uri Uri { get; set; }
            public IPAddress IPAddress { get; set; }
            public PhysicalAddress PhysicalAddress { get; set; }

            public bool? NullableBool { get; set; }
            public byte? NullableUInt8 { get; set; }
            public ushort? NullableUInt16 { get; set; }
            public uint? NullableUInt32 { get; set; }
            public ulong? NullableUInt64 { get; set; }
            public sbyte? NullableInt8 { get; set; }
            public short? NullableInt16 { get; set; }
            public int? NullableInt32 { get; set; }
            public long? NullableInt64 { get; set; }
            public char? NullableChar { get; set; }
            public decimal? NullableDecimal { get; set; }
            public double? NullableDouble { get; set; }
            public float? NullableFloat { get; set; }
            public Guid? NullableGuid { get; set; }
            public DateTime? NullableDateTime { get; set; }
            public DateOnly? NullableDateOnly { get; set; }
            public TimeOnly? NullableTimeOnly { get; set; }
            public TimeSpan? NullableTimeSpan { get; set; }
            public string NullableString { get; set; }
            public byte[] NullableBytes { get; set; }
            public Uri NullableUri { get; set; }
            public IPAddress NullableIPAddress { get; set; }
            public PhysicalAddress NullablePhysicalAddress { get; set; }

            public bool[] BoolArray { get; set; }
            public byte[] UInt8Array { get; set; }
            public ushort[] UInt16Array { get; set; }
            public uint[] UInt32Array { get; set; }
            public ulong[] UInt64Array { get; set; }
            public sbyte[] Int8Array { get; set; }
            public short[] Int16Array { get; set; }
            public int[] Int32Array { get; set; }
            public long[] Int64Array { get; set; }
            public char[] CharArray { get; set; }
            public decimal[] DecimalArray { get; set; }
            public double[] DoubleArray { get; set; }
            public float[] FloatArray { get; set; }
            public Guid[] GuidArray { get; set; }
            public DateTime[] DateTimeArray { get; set; }
            public DateOnly[] DateOnlyArray { get; set; }
            public TimeOnly[] TimeOnlyArray { get; set; }
            public TimeSpan[] TimeSpanArray { get; set; }
            public string[] StringArray { get; set; }
            public byte[][] BytesArray { get; set; }
            public Uri[] UriArray { get; set; }
            public IPAddress[] IPAddressArray { get; set; }
            public PhysicalAddress[] PhysicalAddressArray { get; set; }

            public bool?[] NullableBoolArray { get; set; }
            public byte?[] NullableUInt8Array { get; set; }
            public ushort?[] NullableUInt16Array { get; set; }
            public uint?[] NullableUInt32Array { get; set; }
            public ulong?[] NullableUInt64Array { get; set; }
            public sbyte?[] NullableInt8Array { get; set; }
            public short?[] NullableInt16Array { get; set; }
            public int?[] NullableInt32Array { get; set; }
            public long?[] NullableInt64Array { get; set; }
            public char?[] NullableCharArray { get; set; }
            public decimal?[] NullableDecimalArray { get; set; }
            public double?[] NullableDoubleArray { get; set; }
            public float?[] NullableFloatArray { get; set; }
            public Guid?[] NullableGuidArray { get; set; }
            public DateTime?[] NullableDateTimeArray { get; set; }
            public DateOnly?[] NullableDateOnlyArray { get; set; }
            public TimeOnly?[] NullableTimeOnlyArray { get; set; }
            public TimeSpan?[] NullableTimeSpanArray { get; set; }
            public string[] NullableStringArray { get; set; }
            public byte[][] NullableBytesArray { get; set; }
            public Uri[] NullableUriArray { get; set; }
            public IPAddress[] NullableIPAddressArray { get; set; }
            public PhysicalAddress[] NullablePhysicalAddressArray { get; set; }

            public Enum8 Enum8 { get; set; }
            public Enum16 Enum16 { get; set; }
            public Enum32 Enum32 { get; set; }
            public Enum64 Enum64 { get; set; }
            public EnumU8 EnumU8 { get; set; }
            public EnumU16 EnumU16 { get; set; }
            public EnumU32 EnumU32 { get; set; }
            public EnumU64 EnumU64 { get; set; }

            public Enum8 Enum8AsString { get; set; }
            public Enum16 Enum16AsString { get; set; }
            public Enum32 Enum32AsString { get; set; }
            public Enum64 Enum64AsString { get; set; }
            public EnumU8 EnumU8AsString { get; set; }
            public EnumU16 EnumU16AsString { get; set; }
            public EnumU32 EnumU32AsString { get; set; }
            public EnumU64 EnumU64AsString { get; set; }

            public Enum8? NullableEnum8 { get; set; }
            public Enum16? NullableEnum16 { get; set; }
            public Enum32? NullableEnum32 { get; set; }
            public Enum64? NullableEnum64 { get; set; }
            public EnumU8? NullableEnumU8 { get; set; }
            public EnumU16? NullableEnumU16 { get; set; }
            public EnumU32? NullableEnumU32 { get; set; }
            public EnumU64? NullableEnumU64 { get; set; }

            public Enum8? NullableEnum8AsString { get; set; }
            public Enum16? NullableEnum16AsString { get; set; }
            public Enum32? NullableEnum32AsString { get; set; }
            public Enum64? NullableEnum64AsString { get; set; }
            public EnumU8? NullableEnumU8AsString { get; set; }
            public EnumU16? NullableEnumU16AsString { get; set; }
            public EnumU32? NullableEnumU32AsString { get; set; }
            public EnumU64? NullableEnumU64AsString { get; set; }

            public List<Enum8> Enum8Collection { get; set; }
            public List<Enum16> Enum16Collection { get; set; }
            public List<Enum32> Enum32Collection { get; set; }
            public List<Enum64> Enum64Collection { get; set; }
            public List<EnumU8> EnumU8Collection { get; set; }
            public List<EnumU16> EnumU16Collection { get; set; }
            public List<EnumU32> EnumU32Collection { get; set; }
            public List<EnumU64> EnumU64Collection { get; set; }

            public List<Enum8> Enum8AsStringCollection { get; set; }
            public List<Enum16> Enum16AsStringCollection { get; set; }
            public List<Enum32> Enum32AsStringCollection { get; set; }
            public List<Enum64> Enum64AsStringCollection { get; set; }
            public List<EnumU8> EnumU8AsStringCollection { get; set; }
            public List<EnumU16> EnumU16AsStringCollection { get; set; }
            public List<EnumU32> EnumU32AsStringCollection { get; set; }
            public List<EnumU64> EnumU64AsStringCollection { get; set; }

            public List<Enum8?> NullableEnum8Collection { get; set; }
            public List<Enum16?> NullableEnum16Collection { get; set; }
            public List<Enum32?> NullableEnum32Collection { get; set; }
            public List<Enum64?> NullableEnum64Collection { get; set; }
            public List<EnumU8?> NullableEnumU8Collection { get; set; }
            public List<EnumU16?> NullableEnumU16Collection { get; set; }
            public List<EnumU32?> NullableEnumU32Collection { get; set; }
            public List<EnumU64?> NullableEnumU64Collection { get; set; }

            public List<Enum8?> NullableEnum8AsStringCollection { get; set; }
            public List<Enum16?> NullableEnum16AsStringCollection { get; set; }
            public List<Enum32?> NullableEnum32AsStringCollection { get; set; }
            public List<Enum64?> NullableEnum64AsStringCollection { get; set; }
            public List<EnumU8?> NullableEnumU8AsStringCollection { get; set; }
            public List<EnumU16?> NullableEnumU16AsStringCollection { get; set; }
            public List<EnumU32?> NullableEnumU32AsStringCollection { get; set; }
            public List<EnumU64?> NullableEnumU64AsStringCollection { get; set; }

            public Enum8[] Enum8Array { get; set; }
            public Enum16[] Enum16Array { get; set; }
            public Enum32[] Enum32Array { get; set; }
            public Enum64[] Enum64Array { get; set; }
            public EnumU8[] EnumU8Array { get; set; }
            public EnumU16[] EnumU16Array { get; set; }
            public EnumU32[] EnumU32Array { get; set; }
            public EnumU64[] EnumU64Array { get; set; }

            public Enum8[] Enum8AsStringArray { get; set; }
            public Enum16[] Enum16AsStringArray { get; set; }
            public Enum32[] Enum32AsStringArray { get; set; }
            public Enum64[] Enum64AsStringArray { get; set; }
            public EnumU8[] EnumU8AsStringArray { get; set; }
            public EnumU16[] EnumU16AsStringArray { get; set; }
            public EnumU32[] EnumU32AsStringArray { get; set; }
            public EnumU64[] EnumU64AsStringArray { get; set; }

            public Enum8?[] NullableEnum8Array { get; set; }
            public Enum16?[] NullableEnum16Array { get; set; }
            public Enum32?[] NullableEnum32Array { get; set; }
            public Enum64?[] NullableEnum64Array { get; set; }
            public EnumU8?[] NullableEnumU8Array { get; set; }
            public EnumU16?[] NullableEnumU16Array { get; set; }
            public EnumU32?[] NullableEnumU32Array { get; set; }
            public EnumU64?[] NullableEnumU64Array { get; set; }

            public Enum8?[] NullableEnum8AsStringArray { get; set; }
            public Enum16?[] NullableEnum16AsStringArray { get; set; }
            public Enum32?[] NullableEnum32AsStringArray { get; set; }
            public Enum64?[] NullableEnum64AsStringArray { get; set; }
            public EnumU8?[] NullableEnumU8AsStringArray { get; set; }
            public EnumU16?[] NullableEnumU16AsStringArray { get; set; }
            public EnumU32?[] NullableEnumU32AsStringArray { get; set; }
            public EnumU64?[] NullableEnumU64AsStringArray { get; set; }

            public bool BoolToStringConverterProperty { get; set; }
            public bool BoolToTwoValuesConverterProperty { get; set; }
            public bool BoolToZeroOneConverterProperty { get; set; }
            public byte[] BytesToStringConverterProperty { get; set; }
            public int CastingConverterProperty { get; set; }
            public char CharToStringConverterProperty { get; set; }
            public DateOnly DateOnlyToStringConverterProperty { get; set; }
            public DateTimeOffset DateTimeOffsetToBinaryConverterProperty { get; set; }
            public DateTimeOffset DateTimeOffsetToBytesConverterProperty { get; set; }
            public DateTimeOffset DateTimeOffsetToStringConverterProperty { get; set; }
            public DateTime DateTimeToBinaryConverterProperty { get; set; }
            public DateTime DateTimeToStringConverterProperty { get; set; }
            public DateTime DateTimeToTicksConverterProperty { get; set; }
            public Enum32 EnumToNumberConverterProperty { get; set; }
            public Enum32 EnumToStringConverterProperty { get; set; }
            public Guid GuidToBytesConverterProperty { get; set; }
            public Guid GuidToStringConverterProperty { get; set; }
            public IPAddress IPAddressToBytesConverterProperty { get; set; }
            public IPAddress IPAddressToStringConverterProperty { get; set; }
            public int IntNumberToBytesConverterProperty { get; set; }
            public decimal DecimalNumberToBytesConverterProperty { get; set; }
            public double DoubleNumberToBytesConverterProperty { get; set; }
            public int IntNumberToStringConverterProperty { get; set; }
            public decimal DecimalNumberToStringConverterProperty { get; set; }
            public double DoubleNumberToStringConverterProperty { get; set; }
            public PhysicalAddress PhysicalAddressToBytesConverterProperty { get; set; }
            public PhysicalAddress PhysicalAddressToStringConverterProperty { get; set; }
            public string StringToBoolConverterProperty { get; set; }
            public string StringToBytesConverterProperty { get; set; }
            public string StringToCharConverterProperty { get; set; }
            public string StringToDateOnlyConverterProperty { get; set; }
            public string StringToDateTimeConverterProperty { get; set; }
            public string StringToDateTimeOffsetConverterProperty { get; set; }
            public string StringToEnumConverterProperty { get; set; }
            public string StringToGuidConverterProperty { get; set; }
            public string StringToIntNumberConverterProperty { get; set; }
            public string StringToDecimalNumberConverterProperty { get; set; }
            public string StringToDoubleNumberConverterProperty { get; set; }
            public string StringToTimeOnlyConverterProperty { get; set; }
            public string StringToTimeSpanConverterProperty { get; set; }
            public string StringToUriConverterProperty { get; set; }
            public TimeOnly TimeOnlyToStringConverterProperty { get; set; }
            public TimeOnly TimeOnlyToTicksConverterProperty { get; set; }
            public TimeSpan TimeSpanToStringConverterProperty { get; set; }
            public TimeSpan TimeSpanToTicksConverterProperty { get; set; }
            public Uri UriToStringConverterProperty { get; set; }

            public int? NullIntToNullStringConverterProperty { get; set; }
        }

        public readonly record struct ManyTypesId(int Id);

        public class ManyTypesIdConverter : ValueConverter<ManyTypesId, int>
        {
            public ManyTypesIdConverter()
                : base(v => v.Id, v => new ManyTypesId(v))
            {
            }
        }

        public enum Enum8 : sbyte
        {
            Min = sbyte.MinValue,
            Default = 0,
            One = 1,
            Max = sbyte.MaxValue
        }

        public enum Enum16 : short
        {
            Min = short.MinValue,
            Default = 0,
            One = 1,
            Max = short.MaxValue
        }

        public enum Enum32
        {
            Min = int.MinValue,
            Default = 0,
            One = 1,
            Max = int.MaxValue
        }

        public enum Enum64 : long
        {
            Min = long.MinValue,
            Default = 0,
            One = 1,
            Max = long.MaxValue
        }

        public enum EnumU8 : byte
        {
            Min = byte.MinValue,
            Default = 0,
            One = 1,
            Max = byte.MaxValue
        }

        public enum EnumU16 : ushort
        {
            Min = ushort.MinValue,
            Default = 0,
            One = 1,
            Max = ushort.MaxValue
        }

        public enum EnumU32 : uint
        {
            Min = uint.MinValue,
            Default = 0,
            One = 1,
            Max = uint.MaxValue
        }

        public enum EnumU64 : ulong
        {
            Min = ulong.MinValue,
            Default = 0,
            One = 1,
            Max = ulong.MaxValue
        }

        public class PrincipalBase : AbstractBase
        {
            public new long? Id { get; set; }
            public Guid AlternateId;

            public AnEnum Enum1 { get; set; }
            public AnEnum? Enum2 { get; set; }
            public AFlagsEnum FlagsEnum1 { get; set; }
            public AFlagsEnum FlagsEnum2 { get; set; }

            public List<short> ValueTypeList { get; set; }
            public IList<byte> ValueTypeIList { get; set; }
            public DateTime[] ValueTypeArray { get; set; }
            public IEnumerable<byte> ValueTypeEnumerable { get; set; }

            public List<IPAddress> RefTypeList { get; set; }
            public IList<string> RefTypeIList { get; set; }
            public IPAddress[] RefTypeArray { get; set; }
            public IEnumerable<string> RefTypeEnumerable { get; set; }

            private OwnedType _ownedField;
            public OwnedType Owned { get => _ownedField; set => _ownedField = value; }
            public ICollection<PrincipalBase> Deriveds { get; set; }
        }

        public class PrincipalDerived<TDependent> : PrincipalBase
        {
            public TDependent Dependent { get; set; }
            protected ICollection<OwnedType> ManyOwned;
            public ICollection<PrincipalBase> Principals { get; set; }
        }

        public class DependentBase<TKey> : AbstractBase
        {
            public DependentBase(TKey id)
            {
                Id = id;
            }

            private new TKey Id { get; }

            public PrincipalDerived<DependentBase<TKey>> Principal { get; set; }
        }

        public class DependentDerived<TKey> : DependentBase<TKey>
        {
            public DependentDerived(TKey id)
                : base(id)
            {
            }

            private string Data { get; set; }
        }

        public class OwnedType : INotifyPropertyChanged, INotifyPropertyChanging
        {
            private DbContext _context;

            public OwnedType()
            {
            }

            public OwnedType(DbContext context)
            {
                Context = context;
            }

            public DbContext Context
            {
                get => _context;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Context"));
                    _context = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs("Context"));
                }
            }

            public int Number { get; set; }

            [NotMapped]
            public PrincipalBase Principal { get; set; }

            private string _details;
            private List<short> _valueTypeList;
            private DateTime[] _valueTypeArray;
            private IEnumerable<byte> _valueTypeEnumerable;
            private List<IPAddress> _refTypeList;
            private IList<string> _refTypeIList;
            private IPAddress[] _refTypeArray;
            private IEnumerable<string> _refTypeEnumerable;

            public string Details
            {
                get => _details;
                set => _details = value;
            }

            public event PropertyChangedEventHandler PropertyChanged;
            public event PropertyChangingEventHandler PropertyChanging;

            public List<short> ValueTypeList
            {
                get => _valueTypeList;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueTypeList)));
                    _valueTypeList = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(ValueTypeList)));
                }
            }

            public IList<byte> ValueTypeIList { get; set; }

            public DateTime[] ValueTypeArray
            {
                get => _valueTypeArray;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueTypeArray)));
                    _valueTypeArray = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(ValueTypeArray)));
                }
            }

            public IEnumerable<byte> ValueTypeEnumerable
            {
                get => _valueTypeEnumerable;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(ValueTypeEnumerable)));
                    _valueTypeEnumerable = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(ValueTypeEnumerable)));
                }
            }

            public List<IPAddress> RefTypeList
            {
                get => _refTypeList;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeList)));
                    _refTypeList = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeList)));
                }
            }

            public IList<string> RefTypeIList
            {
                get => _refTypeIList;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeIList)));
                    _refTypeIList = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeIList)));
                }
            }

            public IPAddress[] RefTypeArray
            {
                get => _refTypeArray;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeArray)));
                    _refTypeArray = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeArray)));
                }
            }

            public IEnumerable<string> RefTypeEnumerable
            {
                get => _refTypeEnumerable;
                set
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(RefTypeEnumerable)));
                    _refTypeEnumerable = value;
                    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(nameof(RefTypeEnumerable)));
                }
            }
        }

        [ConditionalFact]
        public void Sqlite()
            => Test(
                new SqliteContext(),
                new CompiledModelCodeGenerationOptions { ModelNamespace = "Microsoft.EntityFrameworkCore.Metadata" },
                code => Assert.Collection(
                    code,
                    c => AssertFileContents(
                        "SqliteContextModel.cs",
                        """
// <auto-generated />
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    [DbContext(typeof(CSharpRuntimeModelCodeGeneratorTest.SqliteContext))]
    public partial class SqliteContextModel : RuntimeModel
    {
        private static readonly bool _useOldBehavior31751 =
            System.AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31751", out var enabled31751) && enabled31751;

        static SqliteContextModel()
        {
            var model = new SqliteContextModel();

            if (_useOldBehavior31751)
            {
                model.Initialize();
            }
            else
            {
                var thread = new System.Threading.Thread(RunInitialization, 10 * 1024 * 1024);
                thread.Start();
                thread.Join();

                void RunInitialization()
                {
                    model.Initialize();
                }
            }

            model.Customize();
            _instance = model;
        }

        private static SqliteContextModel _instance;
        public static IModel Instance => _instance;

        partial void Initialize();

        partial void Customize();
    }
}
""", c),
                    c => AssertFileContents(
                        "SqliteContextModelBuilder.cs",
                        """
// <auto-generated />
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Migrations;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    public partial class SqliteContextModel
    {
        partial void Initialize()
        {
            var data = DataEntityType.Create(this);
            var dependentBase = DependentBaseEntityType.Create(this);
            var manyTypes = ManyTypesEntityType.Create(this);
            var principalBase = PrincipalBaseEntityType.Create(this);
            var ownedType = OwnedTypeEntityType.Create(this);
            var ownedType0 = OwnedType0EntityType.Create(this);
            var principalBasePrincipalDerivedDependentBasebyte = PrincipalBasePrincipalDerivedDependentBasebyteEntityType.Create(this);
            var dependentDerived = DependentDerivedEntityType.Create(this, dependentBase);
            var principalDerived = PrincipalDerivedEntityType.Create(this, principalBase);

            DependentBaseEntityType.CreateForeignKey1(dependentBase, principalBase);
            DependentBaseEntityType.CreateForeignKey2(dependentBase, principalDerived);
            OwnedTypeEntityType.CreateForeignKey1(ownedType, principalBase);
            OwnedTypeEntityType.CreateForeignKey2(ownedType, ownedType);
            OwnedType0EntityType.CreateForeignKey1(ownedType0, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey1(principalBasePrincipalDerivedDependentBasebyte, principalDerived);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateForeignKey2(principalBasePrincipalDerivedDependentBasebyte, principalBase);
            PrincipalDerivedEntityType.CreateForeignKey1(principalDerived, principalBase);

            PrincipalBaseEntityType.CreateSkipNavigation1(principalBase, principalDerived, principalBasePrincipalDerivedDependentBasebyte);
            PrincipalDerivedEntityType.CreateSkipNavigation1(principalDerived, principalBase, principalBasePrincipalDerivedDependentBasebyte);

            DataEntityType.CreateAnnotations(data);
            DependentBaseEntityType.CreateAnnotations(dependentBase);
            ManyTypesEntityType.CreateAnnotations(manyTypes);
            PrincipalBaseEntityType.CreateAnnotations(principalBase);
            OwnedTypeEntityType.CreateAnnotations(ownedType);
            OwnedType0EntityType.CreateAnnotations(ownedType0);
            PrincipalBasePrincipalDerivedDependentBasebyteEntityType.CreateAnnotations(principalBasePrincipalDerivedDependentBasebyte);
            DependentDerivedEntityType.CreateAnnotations(dependentDerived);
            PrincipalDerivedEntityType.CreateAnnotations(principalDerived);

            AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel());
        }

        private IRelationalModel CreateRelationalModel()
        {
            var relationalModel = new RelationalModel(this);

            var data = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data")!;

            var defaultTableMappings = new List<TableMappingBase<ColumnMappingBase>>();
            data.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", null, relationalModel);
            var blobColumnBase = new ColumnBase<ColumnMappingBase>("Blob", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Blob", blobColumnBase);
            var idColumnBase = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Id", idColumnBase);
            var pointColumnBase = new ColumnBase<ColumnMappingBase>("Point", "POINT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.Columns.Add("Point", pointColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase = new TableMappingBase<ColumnMappingBase>(data, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase, false);
            defaultTableMappings.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase, data.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)blobColumnBase, data.FindProperty("Blob")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase, data.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDataMappingBase);

            var tableMappings = new List<TableMapping>();
            data.SetRuntimeAnnotation("Relational:TableMappings", tableMappings);
            var dataTable = new Table("Data", null, relationalModel);
            var idColumn = new Column("Id", "INTEGER", dataTable);
            dataTable.Columns.Add("Id", idColumn);
            var blobColumn = new Column("Blob", "BLOB", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Blob", blobColumn);
            var pointColumn = new Column("Point", "POINT", dataTable)
            {
                IsNullable = true
            };
            dataTable.Columns.Add("Point", pointColumn);
            var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
            dataTable.PrimaryKey = pK_Data;
            var pK_DataUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                new[] { "Id" });
            pK_Data.MappedKeys.Add(pK_DataUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DataUc).Add(pK_Data);
            dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
            relationalModel.Tables.Add(("Data", null), dataTable);
            var dataTableMapping = new TableMapping(data, dataTable, true);
            dataTable.AddTypeMapping(dataTableMapping, false);
            tableMappings.Add(dataTableMapping);
            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
            RelationalModel.CreateColumnMapping(pointColumn, data.FindProperty("Point")!, dataTableMapping);

            var dependentBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>")!;

            var defaultTableMappings0 = new List<TableMappingBase<ColumnMappingBase>>();
            dependentBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings0);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", null, relationalModel);
            var dataColumnBase = new ColumnBase<ColumnMappingBase>("Data", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Data", dataColumnBase);
            var enumDiscriminatorColumnBase = new ColumnBase<ColumnMappingBase>("EnumDiscriminator", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("EnumDiscriminator", enumDiscriminatorColumnBase);
            var idColumnBase0 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase0);
            var moneyColumnBase = new ColumnBase<ColumnMappingBase>("Money", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Money", moneyColumnBase);
            var principalAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalAlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalAlternateId", principalAlternateIdColumnBase);
            var principalIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalId", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("PrincipalId", principalIdColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(dependentBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings0.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentBase.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentBase.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentBase.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase0, dependentBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings0 = new List<TableMapping>();
            dependentBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings0);
            var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
            var principalIdColumn = new Column("PrincipalId", "INTEGER", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
            var principalAlternateIdColumn = new Column("PrincipalAlternateId", "TEXT", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
            var dataColumn = new Column("Data", "TEXT", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Data", dataColumn);
            var enumDiscriminatorColumn = new Column("EnumDiscriminator", "INTEGER", dependentBasebyteTable);
            dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
            var idColumn0 = new Column("Id", "INTEGER", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Id", idColumn0);
            var moneyColumn = new Column("Money", "TEXT", dependentBasebyteTable)
            {
                IsNullable = true
            };
            dependentBasebyteTable.Columns.Add("Money", moneyColumn);
            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
            var pK_DependentBasebyteUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" });
            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteUc).Add(pK_DependentBasebyte);
            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
            var iX_DependentBasebyte_PrincipalId = new TableIndex(
            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" });
            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
            relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
            var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping, false);
            tableMappings0.Add(dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentBase.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentBase.FindProperty("PrincipalId")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentBase.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(idColumn0, dependentBase.FindProperty("Id")!, dependentBasebyteTableMapping);

            var dependentDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>")!;

            var defaultTableMappings1 = new List<TableMappingBase<ColumnMappingBase>>();
            dependentDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings1);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0 = new TableMappingBase<ColumnMappingBase>(dependentDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0, false);
            defaultTableMappings1.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalAlternateIdColumnBase, dependentDerived.FindProperty("PrincipalAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalIdColumnBase, dependentDerived.FindProperty("PrincipalId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dataColumnBase, dependentDerived.FindProperty("Data")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumDiscriminatorColumnBase, dependentDerived.FindProperty("EnumDiscriminator")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase0, dependentDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)moneyColumnBase, dependentDerived.FindProperty("Money")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase0);

            var tableMappings1 = new List<TableMapping>();
            dependentDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings1);
            var dependentBasebyteTableMapping0 = new TableMapping(dependentDerived, dependentBasebyteTable, true)
            {
                IsSharedTablePrincipal = false,
            };
            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping0, false);
            tableMappings1.Add(dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalAlternateIdColumn, dependentDerived.FindProperty("PrincipalAlternateId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(principalIdColumn, dependentDerived.FindProperty("PrincipalId")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(idColumn0, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
            RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);

            var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes")!;

            var defaultTableMappings2 = new List<TableMappingBase<ColumnMappingBase>>();
            manyTypes.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings2);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", null, relationalModel);
            var boolColumnBase = new ColumnBase<ColumnMappingBase>("Bool", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bool", boolColumnBase);
            var boolArrayColumnBase = new ColumnBase<ColumnMappingBase>("BoolArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BoolArray", boolArrayColumnBase);
            var boolToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("BoolToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BoolToStringConverterProperty", boolToStringConverterPropertyColumnBase);
            var boolToTwoValuesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("BoolToTwoValuesConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BoolToTwoValuesConverterProperty", boolToTwoValuesConverterPropertyColumnBase);
            var boolToZeroOneConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("BoolToZeroOneConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BoolToZeroOneConverterProperty", boolToZeroOneConverterPropertyColumnBase);
            var bytesColumnBase = new ColumnBase<ColumnMappingBase>("Bytes", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Bytes", bytesColumnBase);
            var bytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("BytesArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BytesArray", bytesArrayColumnBase);
            var bytesToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("BytesToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("BytesToStringConverterProperty", bytesToStringConverterPropertyColumnBase);
            var castingConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("CastingConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("CastingConverterProperty", castingConverterPropertyColumnBase);
            var charColumnBase = new ColumnBase<ColumnMappingBase>("Char", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Char", charColumnBase);
            var charArrayColumnBase = new ColumnBase<ColumnMappingBase>("CharArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("CharArray", charArrayColumnBase);
            var charToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("CharToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("CharToStringConverterProperty", charToStringConverterPropertyColumnBase);
            var dateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("DateOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnly", dateOnlyColumnBase);
            var dateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnlyArray", dateOnlyArrayColumnBase);
            var dateOnlyToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DateOnlyToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateOnlyToStringConverterProperty", dateOnlyToStringConverterPropertyColumnBase);
            var dateTimeColumnBase = new ColumnBase<ColumnMappingBase>("DateTime", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTime", dateTimeColumnBase);
            var dateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeArray", dateTimeArrayColumnBase);
            var dateTimeOffsetToBinaryConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeOffsetToBinaryConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeOffsetToBinaryConverterProperty", dateTimeOffsetToBinaryConverterPropertyColumnBase);
            var dateTimeOffsetToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeOffsetToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeOffsetToBytesConverterProperty", dateTimeOffsetToBytesConverterPropertyColumnBase);
            var dateTimeOffsetToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeOffsetToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeOffsetToStringConverterProperty", dateTimeOffsetToStringConverterPropertyColumnBase);
            var dateTimeToBinaryConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeToBinaryConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeToBinaryConverterProperty", dateTimeToBinaryConverterPropertyColumnBase);
            var dateTimeToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeToStringConverterProperty", dateTimeToStringConverterPropertyColumnBase);
            var dateTimeToTicksConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DateTimeToTicksConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DateTimeToTicksConverterProperty", dateTimeToTicksConverterPropertyColumnBase);
            var decimalColumnBase = new ColumnBase<ColumnMappingBase>("Decimal", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Decimal", decimalColumnBase);
            var decimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("DecimalArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DecimalArray", decimalArrayColumnBase);
            var decimalNumberToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DecimalNumberToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DecimalNumberToBytesConverterProperty", decimalNumberToBytesConverterPropertyColumnBase);
            var decimalNumberToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DecimalNumberToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DecimalNumberToStringConverterProperty", decimalNumberToStringConverterPropertyColumnBase);
            var doubleColumnBase = new ColumnBase<ColumnMappingBase>("Double", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Double", doubleColumnBase);
            var doubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("DoubleArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DoubleArray", doubleArrayColumnBase);
            var doubleNumberToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DoubleNumberToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DoubleNumberToBytesConverterProperty", doubleNumberToBytesConverterPropertyColumnBase);
            var doubleNumberToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("DoubleNumberToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("DoubleNumberToStringConverterProperty", doubleNumberToStringConverterPropertyColumnBase);
            var enum16ColumnBase = new ColumnBase<ColumnMappingBase>("Enum16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum16", enum16ColumnBase);
            var enum16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum16Array", enum16ArrayColumnBase);
            var enum16AsStringColumnBase = new ColumnBase<ColumnMappingBase>("Enum16AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum16AsString", enum16AsStringColumnBase);
            var enum16AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum16AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum16AsStringArray", enum16AsStringArrayColumnBase);
            var enum16AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum16AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum16AsStringCollection", enum16AsStringCollectionColumnBase);
            var enum16CollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum16Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum16Collection", enum16CollectionColumnBase);
            var enum32ColumnBase = new ColumnBase<ColumnMappingBase>("Enum32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum32", enum32ColumnBase);
            var enum32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum32Array", enum32ArrayColumnBase);
            var enum32AsStringColumnBase = new ColumnBase<ColumnMappingBase>("Enum32AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum32AsString", enum32AsStringColumnBase);
            var enum32AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum32AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum32AsStringArray", enum32AsStringArrayColumnBase);
            var enum32AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum32AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum32AsStringCollection", enum32AsStringCollectionColumnBase);
            var enum32CollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum32Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum32Collection", enum32CollectionColumnBase);
            var enum64ColumnBase = new ColumnBase<ColumnMappingBase>("Enum64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum64", enum64ColumnBase);
            var enum64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum64Array", enum64ArrayColumnBase);
            var enum64AsStringColumnBase = new ColumnBase<ColumnMappingBase>("Enum64AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum64AsString", enum64AsStringColumnBase);
            var enum64AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum64AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum64AsStringArray", enum64AsStringArrayColumnBase);
            var enum64AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum64AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum64AsStringCollection", enum64AsStringCollectionColumnBase);
            var enum64CollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum64Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum64Collection", enum64CollectionColumnBase);
            var enum8ColumnBase = new ColumnBase<ColumnMappingBase>("Enum8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum8", enum8ColumnBase);
            var enum8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum8Array", enum8ArrayColumnBase);
            var enum8AsStringColumnBase = new ColumnBase<ColumnMappingBase>("Enum8AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum8AsString", enum8AsStringColumnBase);
            var enum8AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("Enum8AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum8AsStringArray", enum8AsStringArrayColumnBase);
            var enum8AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum8AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum8AsStringCollection", enum8AsStringCollectionColumnBase);
            var enum8CollectionColumnBase = new ColumnBase<ColumnMappingBase>("Enum8Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Enum8Collection", enum8CollectionColumnBase);
            var enumToNumberConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("EnumToNumberConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumToNumberConverterProperty", enumToNumberConverterPropertyColumnBase);
            var enumToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("EnumToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumToStringConverterProperty", enumToStringConverterPropertyColumnBase);
            var enumU16ColumnBase = new ColumnBase<ColumnMappingBase>("EnumU16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU16", enumU16ColumnBase);
            var enumU16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU16Array", enumU16ArrayColumnBase);
            var enumU16AsStringColumnBase = new ColumnBase<ColumnMappingBase>("EnumU16AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU16AsString", enumU16AsStringColumnBase);
            var enumU16AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU16AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU16AsStringArray", enumU16AsStringArrayColumnBase);
            var enumU16AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU16AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU16AsStringCollection", enumU16AsStringCollectionColumnBase);
            var enumU16CollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU16Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU16Collection", enumU16CollectionColumnBase);
            var enumU32ColumnBase = new ColumnBase<ColumnMappingBase>("EnumU32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU32", enumU32ColumnBase);
            var enumU32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU32Array", enumU32ArrayColumnBase);
            var enumU32AsStringColumnBase = new ColumnBase<ColumnMappingBase>("EnumU32AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU32AsString", enumU32AsStringColumnBase);
            var enumU32AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU32AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU32AsStringArray", enumU32AsStringArrayColumnBase);
            var enumU32AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU32AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU32AsStringCollection", enumU32AsStringCollectionColumnBase);
            var enumU32CollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU32Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU32Collection", enumU32CollectionColumnBase);
            var enumU64ColumnBase = new ColumnBase<ColumnMappingBase>("EnumU64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU64", enumU64ColumnBase);
            var enumU64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU64Array", enumU64ArrayColumnBase);
            var enumU64AsStringColumnBase = new ColumnBase<ColumnMappingBase>("EnumU64AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU64AsString", enumU64AsStringColumnBase);
            var enumU64AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU64AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU64AsStringArray", enumU64AsStringArrayColumnBase);
            var enumU64AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU64AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU64AsStringCollection", enumU64AsStringCollectionColumnBase);
            var enumU64CollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU64Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU64Collection", enumU64CollectionColumnBase);
            var enumU8ColumnBase = new ColumnBase<ColumnMappingBase>("EnumU8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU8", enumU8ColumnBase);
            var enumU8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU8Array", enumU8ArrayColumnBase);
            var enumU8AsStringColumnBase = new ColumnBase<ColumnMappingBase>("EnumU8AsString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU8AsString", enumU8AsStringColumnBase);
            var enumU8AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("EnumU8AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU8AsStringArray", enumU8AsStringArrayColumnBase);
            var enumU8AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU8AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU8AsStringCollection", enumU8AsStringCollectionColumnBase);
            var enumU8CollectionColumnBase = new ColumnBase<ColumnMappingBase>("EnumU8Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("EnumU8Collection", enumU8CollectionColumnBase);
            var floatColumnBase = new ColumnBase<ColumnMappingBase>("Float", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Float", floatColumnBase);
            var floatArrayColumnBase = new ColumnBase<ColumnMappingBase>("FloatArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("FloatArray", floatArrayColumnBase);
            var guidColumnBase = new ColumnBase<ColumnMappingBase>("Guid", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Guid", guidColumnBase);
            var guidArrayColumnBase = new ColumnBase<ColumnMappingBase>("GuidArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("GuidArray", guidArrayColumnBase);
            var guidToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("GuidToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("GuidToBytesConverterProperty", guidToBytesConverterPropertyColumnBase);
            var guidToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("GuidToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("GuidToStringConverterProperty", guidToStringConverterPropertyColumnBase);
            var iPAddressColumnBase = new ColumnBase<ColumnMappingBase>("IPAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddress", iPAddressColumnBase);
            var iPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("IPAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddressArray", iPAddressArrayColumnBase);
            var iPAddressToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("IPAddressToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddressToBytesConverterProperty", iPAddressToBytesConverterPropertyColumnBase);
            var iPAddressToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("IPAddressToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IPAddressToStringConverterProperty", iPAddressToStringConverterPropertyColumnBase);
            var idColumnBase1 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Id", idColumnBase1);
            var int16ColumnBase = new ColumnBase<ColumnMappingBase>("Int16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16", int16ColumnBase);
            var int16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int16Array", int16ArrayColumnBase);
            var int32ColumnBase = new ColumnBase<ColumnMappingBase>("Int32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32", int32ColumnBase);
            var int32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int32Array", int32ArrayColumnBase);
            var int64ColumnBase = new ColumnBase<ColumnMappingBase>("Int64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64", int64ColumnBase);
            var int64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int64Array", int64ArrayColumnBase);
            var int8ColumnBase = new ColumnBase<ColumnMappingBase>("Int8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8", int8ColumnBase);
            var int8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("Int8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Int8Array", int8ArrayColumnBase);
            var intNumberToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("IntNumberToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IntNumberToBytesConverterProperty", intNumberToBytesConverterPropertyColumnBase);
            var intNumberToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("IntNumberToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("IntNumberToStringConverterProperty", intNumberToStringConverterPropertyColumnBase);
            var nullIntToNullStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("NullIntToNullStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullIntToNullStringConverterProperty", nullIntToNullStringConverterPropertyColumnBase);
            var nullableBoolColumnBase = new ColumnBase<ColumnMappingBase>("NullableBool", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBool", nullableBoolColumnBase);
            var nullableBoolArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBoolArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBoolArray", nullableBoolArrayColumnBase);
            var nullableBytesColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytes", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytes", nullableBytesColumnBase);
            var nullableBytesArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableBytesArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableBytesArray", nullableBytesArrayColumnBase);
            var nullableCharColumnBase = new ColumnBase<ColumnMappingBase>("NullableChar", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableChar", nullableCharColumnBase);
            var nullableCharArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableCharArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableCharArray", nullableCharArrayColumnBase);
            var nullableDateOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnly", nullableDateOnlyColumnBase);
            var nullableDateOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumnBase);
            var nullableDateTimeColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTime", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTime", nullableDateTimeColumnBase);
            var nullableDateTimeArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDateTimeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumnBase);
            var nullableDecimalColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimal", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimal", nullableDecimalColumnBase);
            var nullableDecimalArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDecimalArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumnBase);
            var nullableDoubleColumnBase = new ColumnBase<ColumnMappingBase>("NullableDouble", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDouble", nullableDoubleColumnBase);
            var nullableDoubleArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableDoubleArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumnBase);
            var nullableEnum16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum16", nullableEnum16ColumnBase);
            var nullableEnum16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum16Array", nullableEnum16ArrayColumnBase);
            var nullableEnum16AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum16AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum16AsString", nullableEnum16AsStringColumnBase);
            var nullableEnum16AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum16AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum16AsStringArray", nullableEnum16AsStringArrayColumnBase);
            var nullableEnum16AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum16AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum16AsStringCollection", nullableEnum16AsStringCollectionColumnBase);
            var nullableEnum16CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum16Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum16Collection", nullableEnum16CollectionColumnBase);
            var nullableEnum32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum32", nullableEnum32ColumnBase);
            var nullableEnum32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum32Array", nullableEnum32ArrayColumnBase);
            var nullableEnum32AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum32AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum32AsString", nullableEnum32AsStringColumnBase);
            var nullableEnum32AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum32AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum32AsStringArray", nullableEnum32AsStringArrayColumnBase);
            var nullableEnum32AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum32AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum32AsStringCollection", nullableEnum32AsStringCollectionColumnBase);
            var nullableEnum32CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum32Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum32Collection", nullableEnum32CollectionColumnBase);
            var nullableEnum64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum64", nullableEnum64ColumnBase);
            var nullableEnum64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum64Array", nullableEnum64ArrayColumnBase);
            var nullableEnum64AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum64AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum64AsString", nullableEnum64AsStringColumnBase);
            var nullableEnum64AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum64AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum64AsStringArray", nullableEnum64AsStringArrayColumnBase);
            var nullableEnum64AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum64AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum64AsStringCollection", nullableEnum64AsStringCollectionColumnBase);
            var nullableEnum64CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum64Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum64Collection", nullableEnum64CollectionColumnBase);
            var nullableEnum8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum8", nullableEnum8ColumnBase);
            var nullableEnum8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum8Array", nullableEnum8ArrayColumnBase);
            var nullableEnum8AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum8AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum8AsString", nullableEnum8AsStringColumnBase);
            var nullableEnum8AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum8AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum8AsStringArray", nullableEnum8AsStringArrayColumnBase);
            var nullableEnum8AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum8AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum8AsStringCollection", nullableEnum8AsStringCollectionColumnBase);
            var nullableEnum8CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnum8Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnum8Collection", nullableEnum8CollectionColumnBase);
            var nullableEnumU16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU16", nullableEnumU16ColumnBase);
            var nullableEnumU16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU16Array", nullableEnumU16ArrayColumnBase);
            var nullableEnumU16AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU16AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU16AsString", nullableEnumU16AsStringColumnBase);
            var nullableEnumU16AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU16AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU16AsStringArray", nullableEnumU16AsStringArrayColumnBase);
            var nullableEnumU16AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU16AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU16AsStringCollection", nullableEnumU16AsStringCollectionColumnBase);
            var nullableEnumU16CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU16Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU16Collection", nullableEnumU16CollectionColumnBase);
            var nullableEnumU32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU32", nullableEnumU32ColumnBase);
            var nullableEnumU32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU32Array", nullableEnumU32ArrayColumnBase);
            var nullableEnumU32AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU32AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU32AsString", nullableEnumU32AsStringColumnBase);
            var nullableEnumU32AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU32AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU32AsStringArray", nullableEnumU32AsStringArrayColumnBase);
            var nullableEnumU32AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU32AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU32AsStringCollection", nullableEnumU32AsStringCollectionColumnBase);
            var nullableEnumU32CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU32Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU32Collection", nullableEnumU32CollectionColumnBase);
            var nullableEnumU64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU64", nullableEnumU64ColumnBase);
            var nullableEnumU64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU64Array", nullableEnumU64ArrayColumnBase);
            var nullableEnumU64AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU64AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU64AsString", nullableEnumU64AsStringColumnBase);
            var nullableEnumU64AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU64AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU64AsStringArray", nullableEnumU64AsStringArrayColumnBase);
            var nullableEnumU64AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU64AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU64AsStringCollection", nullableEnumU64AsStringCollectionColumnBase);
            var nullableEnumU64CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU64Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU64Collection", nullableEnumU64CollectionColumnBase);
            var nullableEnumU8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU8", nullableEnumU8ColumnBase);
            var nullableEnumU8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU8Array", nullableEnumU8ArrayColumnBase);
            var nullableEnumU8AsStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU8AsString", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU8AsString", nullableEnumU8AsStringColumnBase);
            var nullableEnumU8AsStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU8AsStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU8AsStringArray", nullableEnumU8AsStringArrayColumnBase);
            var nullableEnumU8AsStringCollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU8AsStringCollection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU8AsStringCollection", nullableEnumU8AsStringCollectionColumnBase);
            var nullableEnumU8CollectionColumnBase = new ColumnBase<ColumnMappingBase>("NullableEnumU8Collection", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableEnumU8Collection", nullableEnumU8CollectionColumnBase);
            var nullableFloatColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloat", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloat", nullableFloatColumnBase);
            var nullableFloatArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableFloatArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableFloatArray", nullableFloatArrayColumnBase);
            var nullableGuidColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuid", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuid", nullableGuidColumnBase);
            var nullableGuidArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableGuidArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableGuidArray", nullableGuidArrayColumnBase);
            var nullableIPAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddress", nullableIPAddressColumnBase);
            var nullableIPAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableIPAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumnBase);
            var nullableInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16", nullableInt16ColumnBase);
            var nullableInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt16Array", nullableInt16ArrayColumnBase);
            var nullableInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32", nullableInt32ColumnBase);
            var nullableInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt32Array", nullableInt32ArrayColumnBase);
            var nullableInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64", nullableInt64ColumnBase);
            var nullableInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt64Array", nullableInt64ArrayColumnBase);
            var nullableInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8", nullableInt8ColumnBase);
            var nullableInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableInt8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableInt8Array", nullableInt8ArrayColumnBase);
            var nullablePhysicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumnBase);
            var nullablePhysicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullablePhysicalAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumnBase);
            var nullableStringColumnBase = new ColumnBase<ColumnMappingBase>("NullableString", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableString", nullableStringColumnBase);
            var nullableStringArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableStringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableStringArray", nullableStringArrayColumnBase);
            var nullableTimeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumnBase);
            var nullableTimeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumnBase);
            var nullableTimeSpanColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpan", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpan", nullableTimeSpanColumnBase);
            var nullableTimeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableTimeSpanArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumnBase);
            var nullableUInt16ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16", nullableUInt16ColumnBase);
            var nullableUInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumnBase);
            var nullableUInt32ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32", nullableUInt32ColumnBase);
            var nullableUInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumnBase);
            var nullableUInt64ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64", nullableUInt64ColumnBase);
            var nullableUInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumnBase);
            var nullableUInt8ColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8", nullableUInt8ColumnBase);
            var nullableUInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUInt8Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumnBase);
            var nullableUriColumnBase = new ColumnBase<ColumnMappingBase>("NullableUri", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUri", nullableUriColumnBase);
            var nullableUriArrayColumnBase = new ColumnBase<ColumnMappingBase>("NullableUriArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("NullableUriArray", nullableUriArrayColumnBase);
            var physicalAddressColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddress", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddress", physicalAddressColumnBase);
            var physicalAddressArrayColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddressArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumnBase);
            var physicalAddressToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddressToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddressToBytesConverterProperty", physicalAddressToBytesConverterPropertyColumnBase);
            var physicalAddressToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("PhysicalAddressToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("PhysicalAddressToStringConverterProperty", physicalAddressToStringConverterPropertyColumnBase);
            var stringColumnBase = new ColumnBase<ColumnMappingBase>("String", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("String", stringColumnBase);
            var stringArrayColumnBase = new ColumnBase<ColumnMappingBase>("StringArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringArray", stringArrayColumnBase);
            var stringToBoolConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToBoolConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToBoolConverterProperty", stringToBoolConverterPropertyColumnBase);
            var stringToBytesConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToBytesConverterProperty", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToBytesConverterProperty", stringToBytesConverterPropertyColumnBase);
            var stringToCharConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToCharConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToCharConverterProperty", stringToCharConverterPropertyColumnBase);
            var stringToDateOnlyConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToDateOnlyConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToDateOnlyConverterProperty", stringToDateOnlyConverterPropertyColumnBase);
            var stringToDateTimeConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToDateTimeConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToDateTimeConverterProperty", stringToDateTimeConverterPropertyColumnBase);
            var stringToDateTimeOffsetConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToDateTimeOffsetConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToDateTimeOffsetConverterProperty", stringToDateTimeOffsetConverterPropertyColumnBase);
            var stringToDecimalNumberConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToDecimalNumberConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToDecimalNumberConverterProperty", stringToDecimalNumberConverterPropertyColumnBase);
            var stringToDoubleNumberConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToDoubleNumberConverterProperty", "REAL", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToDoubleNumberConverterProperty", stringToDoubleNumberConverterPropertyColumnBase);
            var stringToEnumConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToEnumConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToEnumConverterProperty", stringToEnumConverterPropertyColumnBase);
            var stringToGuidConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToGuidConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToGuidConverterProperty", stringToGuidConverterPropertyColumnBase);
            var stringToIntNumberConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToIntNumberConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToIntNumberConverterProperty", stringToIntNumberConverterPropertyColumnBase);
            var stringToTimeOnlyConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToTimeOnlyConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToTimeOnlyConverterProperty", stringToTimeOnlyConverterPropertyColumnBase);
            var stringToTimeSpanConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToTimeSpanConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToTimeSpanConverterProperty", stringToTimeSpanConverterPropertyColumnBase);
            var stringToUriConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("StringToUriConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("StringToUriConverterProperty", stringToUriConverterPropertyColumnBase);
            var timeOnlyColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnly", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnly", timeOnlyColumnBase);
            var timeOnlyArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnlyArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnlyArray", timeOnlyArrayColumnBase);
            var timeOnlyToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnlyToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnlyToStringConverterProperty", timeOnlyToStringConverterPropertyColumnBase);
            var timeOnlyToTicksConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("TimeOnlyToTicksConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeOnlyToTicksConverterProperty", timeOnlyToTicksConverterPropertyColumnBase);
            var timeSpanColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpan", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpan", timeSpanColumnBase);
            var timeSpanArrayColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpanArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpanArray", timeSpanArrayColumnBase);
            var timeSpanToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpanToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpanToStringConverterProperty", timeSpanToStringConverterPropertyColumnBase);
            var timeSpanToTicksConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("TimeSpanToTicksConverterProperty", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("TimeSpanToTicksConverterProperty", timeSpanToTicksConverterPropertyColumnBase);
            var uInt16ColumnBase = new ColumnBase<ColumnMappingBase>("UInt16", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16", uInt16ColumnBase);
            var uInt16ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt16Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt16Array", uInt16ArrayColumnBase);
            var uInt32ColumnBase = new ColumnBase<ColumnMappingBase>("UInt32", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32", uInt32ColumnBase);
            var uInt32ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt32Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt32Array", uInt32ArrayColumnBase);
            var uInt64ColumnBase = new ColumnBase<ColumnMappingBase>("UInt64", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64", uInt64ColumnBase);
            var uInt64ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt64Array", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt64Array", uInt64ArrayColumnBase);
            var uInt8ColumnBase = new ColumnBase<ColumnMappingBase>("UInt8", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8", uInt8ColumnBase);
            var uInt8ArrayColumnBase = new ColumnBase<ColumnMappingBase>("UInt8Array", "BLOB", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UInt8Array", uInt8ArrayColumnBase);
            var uriColumnBase = new ColumnBase<ColumnMappingBase>("Uri", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("Uri", uriColumnBase);
            var uriArrayColumnBase = new ColumnBase<ColumnMappingBase>("UriArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UriArray", uriArrayColumnBase);
            var uriToStringConverterPropertyColumnBase = new ColumnBase<ColumnMappingBase>("UriToStringConverterProperty", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.Columns.Add("UriToStringConverterProperty", uriToStringConverterPropertyColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase = new TableMappingBase<ColumnMappingBase>(manyTypes, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase, false);
            defaultTableMappings2.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase1, manyTypes.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolColumnBase, manyTypes.FindProperty("Bool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolArrayColumnBase, manyTypes.FindProperty("BoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolToStringConverterPropertyColumnBase, manyTypes.FindProperty("BoolToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolToTwoValuesConverterPropertyColumnBase, manyTypes.FindProperty("BoolToTwoValuesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)boolToZeroOneConverterPropertyColumnBase, manyTypes.FindProperty("BoolToZeroOneConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesColumnBase, manyTypes.FindProperty("Bytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesArrayColumnBase, manyTypes.FindProperty("BytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)bytesToStringConverterPropertyColumnBase, manyTypes.FindProperty("BytesToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)castingConverterPropertyColumnBase, manyTypes.FindProperty("CastingConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charColumnBase, manyTypes.FindProperty("Char")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charArrayColumnBase, manyTypes.FindProperty("CharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)charToStringConverterPropertyColumnBase, manyTypes.FindProperty("CharToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyColumnBase, manyTypes.FindProperty("DateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyArrayColumnBase, manyTypes.FindProperty("DateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateOnlyToStringConverterPropertyColumnBase, manyTypes.FindProperty("DateOnlyToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeColumnBase, manyTypes.FindProperty("DateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeArrayColumnBase, manyTypes.FindProperty("DateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeOffsetToBinaryConverterPropertyColumnBase, manyTypes.FindProperty("DateTimeOffsetToBinaryConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeOffsetToBytesConverterPropertyColumnBase, manyTypes.FindProperty("DateTimeOffsetToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeOffsetToStringConverterPropertyColumnBase, manyTypes.FindProperty("DateTimeOffsetToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeToBinaryConverterPropertyColumnBase, manyTypes.FindProperty("DateTimeToBinaryConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeToStringConverterPropertyColumnBase, manyTypes.FindProperty("DateTimeToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)dateTimeToTicksConverterPropertyColumnBase, manyTypes.FindProperty("DateTimeToTicksConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalColumnBase, manyTypes.FindProperty("Decimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalArrayColumnBase, manyTypes.FindProperty("DecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalNumberToBytesConverterPropertyColumnBase, manyTypes.FindProperty("DecimalNumberToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)decimalNumberToStringConverterPropertyColumnBase, manyTypes.FindProperty("DecimalNumberToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleColumnBase, manyTypes.FindProperty("Double")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleArrayColumnBase, manyTypes.FindProperty("DoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleNumberToBytesConverterPropertyColumnBase, manyTypes.FindProperty("DoubleNumberToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)doubleNumberToStringConverterPropertyColumnBase, manyTypes.FindProperty("DoubleNumberToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum16ColumnBase, manyTypes.FindProperty("Enum16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum16ArrayColumnBase, manyTypes.FindProperty("Enum16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum16AsStringColumnBase, manyTypes.FindProperty("Enum16AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum16AsStringArrayColumnBase, manyTypes.FindProperty("Enum16AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum16AsStringCollectionColumnBase, manyTypes.FindProperty("Enum16AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum16CollectionColumnBase, manyTypes.FindProperty("Enum16Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum32ColumnBase, manyTypes.FindProperty("Enum32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum32ArrayColumnBase, manyTypes.FindProperty("Enum32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum32AsStringColumnBase, manyTypes.FindProperty("Enum32AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum32AsStringArrayColumnBase, manyTypes.FindProperty("Enum32AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum32AsStringCollectionColumnBase, manyTypes.FindProperty("Enum32AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum32CollectionColumnBase, manyTypes.FindProperty("Enum32Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum64ColumnBase, manyTypes.FindProperty("Enum64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum64ArrayColumnBase, manyTypes.FindProperty("Enum64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum64AsStringColumnBase, manyTypes.FindProperty("Enum64AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum64AsStringArrayColumnBase, manyTypes.FindProperty("Enum64AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum64AsStringCollectionColumnBase, manyTypes.FindProperty("Enum64AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum64CollectionColumnBase, manyTypes.FindProperty("Enum64Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum8ColumnBase, manyTypes.FindProperty("Enum8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum8ArrayColumnBase, manyTypes.FindProperty("Enum8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum8AsStringColumnBase, manyTypes.FindProperty("Enum8AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum8AsStringArrayColumnBase, manyTypes.FindProperty("Enum8AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum8AsStringCollectionColumnBase, manyTypes.FindProperty("Enum8AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum8CollectionColumnBase, manyTypes.FindProperty("Enum8Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumToNumberConverterPropertyColumnBase, manyTypes.FindProperty("EnumToNumberConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumToStringConverterPropertyColumnBase, manyTypes.FindProperty("EnumToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU16ColumnBase, manyTypes.FindProperty("EnumU16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU16ArrayColumnBase, manyTypes.FindProperty("EnumU16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU16AsStringColumnBase, manyTypes.FindProperty("EnumU16AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU16AsStringArrayColumnBase, manyTypes.FindProperty("EnumU16AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU16AsStringCollectionColumnBase, manyTypes.FindProperty("EnumU16AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU16CollectionColumnBase, manyTypes.FindProperty("EnumU16Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU32ColumnBase, manyTypes.FindProperty("EnumU32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU32ArrayColumnBase, manyTypes.FindProperty("EnumU32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU32AsStringColumnBase, manyTypes.FindProperty("EnumU32AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU32AsStringArrayColumnBase, manyTypes.FindProperty("EnumU32AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU32AsStringCollectionColumnBase, manyTypes.FindProperty("EnumU32AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU32CollectionColumnBase, manyTypes.FindProperty("EnumU32Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU64ColumnBase, manyTypes.FindProperty("EnumU64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU64ArrayColumnBase, manyTypes.FindProperty("EnumU64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU64AsStringColumnBase, manyTypes.FindProperty("EnumU64AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU64AsStringArrayColumnBase, manyTypes.FindProperty("EnumU64AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU64AsStringCollectionColumnBase, manyTypes.FindProperty("EnumU64AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU64CollectionColumnBase, manyTypes.FindProperty("EnumU64Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU8ColumnBase, manyTypes.FindProperty("EnumU8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU8ArrayColumnBase, manyTypes.FindProperty("EnumU8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU8AsStringColumnBase, manyTypes.FindProperty("EnumU8AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU8AsStringArrayColumnBase, manyTypes.FindProperty("EnumU8AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU8AsStringCollectionColumnBase, manyTypes.FindProperty("EnumU8AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enumU8CollectionColumnBase, manyTypes.FindProperty("EnumU8Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatColumnBase, manyTypes.FindProperty("Float")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)floatArrayColumnBase, manyTypes.FindProperty("FloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidColumnBase, manyTypes.FindProperty("Guid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidArrayColumnBase, manyTypes.FindProperty("GuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidToBytesConverterPropertyColumnBase, manyTypes.FindProperty("GuidToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)guidToStringConverterPropertyColumnBase, manyTypes.FindProperty("GuidToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressColumnBase, manyTypes.FindProperty("IPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressArrayColumnBase, manyTypes.FindProperty("IPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressToBytesConverterPropertyColumnBase, manyTypes.FindProperty("IPAddressToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)iPAddressToStringConverterPropertyColumnBase, manyTypes.FindProperty("IPAddressToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ColumnBase, manyTypes.FindProperty("Int16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int16ArrayColumnBase, manyTypes.FindProperty("Int16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ColumnBase, manyTypes.FindProperty("Int32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int32ArrayColumnBase, manyTypes.FindProperty("Int32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ColumnBase, manyTypes.FindProperty("Int64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int64ArrayColumnBase, manyTypes.FindProperty("Int64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ColumnBase, manyTypes.FindProperty("Int8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)int8ArrayColumnBase, manyTypes.FindProperty("Int8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)intNumberToBytesConverterPropertyColumnBase, manyTypes.FindProperty("IntNumberToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)intNumberToStringConverterPropertyColumnBase, manyTypes.FindProperty("IntNumberToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullIntToNullStringConverterPropertyColumnBase, manyTypes.FindProperty("NullIntToNullStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolColumnBase, manyTypes.FindProperty("NullableBool")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBoolArrayColumnBase, manyTypes.FindProperty("NullableBoolArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesColumnBase, manyTypes.FindProperty("NullableBytes")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableBytesArrayColumnBase, manyTypes.FindProperty("NullableBytesArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharColumnBase, manyTypes.FindProperty("NullableChar")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableCharArrayColumnBase, manyTypes.FindProperty("NullableCharArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyColumnBase, manyTypes.FindProperty("NullableDateOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateOnlyArrayColumnBase, manyTypes.FindProperty("NullableDateOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeColumnBase, manyTypes.FindProperty("NullableDateTime")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDateTimeArrayColumnBase, manyTypes.FindProperty("NullableDateTimeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalColumnBase, manyTypes.FindProperty("NullableDecimal")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDecimalArrayColumnBase, manyTypes.FindProperty("NullableDecimalArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleColumnBase, manyTypes.FindProperty("NullableDouble")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableDoubleArrayColumnBase, manyTypes.FindProperty("NullableDoubleArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum16ColumnBase, manyTypes.FindProperty("NullableEnum16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum16ArrayColumnBase, manyTypes.FindProperty("NullableEnum16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum16AsStringColumnBase, manyTypes.FindProperty("NullableEnum16AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum16AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnum16AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum16AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnum16AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum16CollectionColumnBase, manyTypes.FindProperty("NullableEnum16Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum32ColumnBase, manyTypes.FindProperty("NullableEnum32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum32ArrayColumnBase, manyTypes.FindProperty("NullableEnum32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum32AsStringColumnBase, manyTypes.FindProperty("NullableEnum32AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum32AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnum32AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum32AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnum32AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum32CollectionColumnBase, manyTypes.FindProperty("NullableEnum32Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum64ColumnBase, manyTypes.FindProperty("NullableEnum64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum64ArrayColumnBase, manyTypes.FindProperty("NullableEnum64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum64AsStringColumnBase, manyTypes.FindProperty("NullableEnum64AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum64AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnum64AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum64AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnum64AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum64CollectionColumnBase, manyTypes.FindProperty("NullableEnum64Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum8ColumnBase, manyTypes.FindProperty("NullableEnum8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum8ArrayColumnBase, manyTypes.FindProperty("NullableEnum8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum8AsStringColumnBase, manyTypes.FindProperty("NullableEnum8AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum8AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnum8AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum8AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnum8AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnum8CollectionColumnBase, manyTypes.FindProperty("NullableEnum8Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU16ColumnBase, manyTypes.FindProperty("NullableEnumU16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU16ArrayColumnBase, manyTypes.FindProperty("NullableEnumU16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU16AsStringColumnBase, manyTypes.FindProperty("NullableEnumU16AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU16AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnumU16AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU16AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnumU16AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU16CollectionColumnBase, manyTypes.FindProperty("NullableEnumU16Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU32ColumnBase, manyTypes.FindProperty("NullableEnumU32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU32ArrayColumnBase, manyTypes.FindProperty("NullableEnumU32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU32AsStringColumnBase, manyTypes.FindProperty("NullableEnumU32AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU32AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnumU32AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU32AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnumU32AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU32CollectionColumnBase, manyTypes.FindProperty("NullableEnumU32Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU64ColumnBase, manyTypes.FindProperty("NullableEnumU64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU64ArrayColumnBase, manyTypes.FindProperty("NullableEnumU64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU64AsStringColumnBase, manyTypes.FindProperty("NullableEnumU64AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU64AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnumU64AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU64AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnumU64AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU64CollectionColumnBase, manyTypes.FindProperty("NullableEnumU64Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU8ColumnBase, manyTypes.FindProperty("NullableEnumU8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU8ArrayColumnBase, manyTypes.FindProperty("NullableEnumU8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU8AsStringColumnBase, manyTypes.FindProperty("NullableEnumU8AsString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU8AsStringArrayColumnBase, manyTypes.FindProperty("NullableEnumU8AsStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU8AsStringCollectionColumnBase, manyTypes.FindProperty("NullableEnumU8AsStringCollection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableEnumU8CollectionColumnBase, manyTypes.FindProperty("NullableEnumU8Collection")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatColumnBase, manyTypes.FindProperty("NullableFloat")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableFloatArrayColumnBase, manyTypes.FindProperty("NullableFloatArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidColumnBase, manyTypes.FindProperty("NullableGuid")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableGuidArrayColumnBase, manyTypes.FindProperty("NullableGuidArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressColumnBase, manyTypes.FindProperty("NullableIPAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableIPAddressArrayColumnBase, manyTypes.FindProperty("NullableIPAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ColumnBase, manyTypes.FindProperty("NullableInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt16ArrayColumnBase, manyTypes.FindProperty("NullableInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ColumnBase, manyTypes.FindProperty("NullableInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt32ArrayColumnBase, manyTypes.FindProperty("NullableInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ColumnBase, manyTypes.FindProperty("NullableInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt64ArrayColumnBase, manyTypes.FindProperty("NullableInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ColumnBase, manyTypes.FindProperty("NullableInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableInt8ArrayColumnBase, manyTypes.FindProperty("NullableInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressColumnBase, manyTypes.FindProperty("NullablePhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullablePhysicalAddressArrayColumnBase, manyTypes.FindProperty("NullablePhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringColumnBase, manyTypes.FindProperty("NullableString")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableStringArrayColumnBase, manyTypes.FindProperty("NullableStringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyColumnBase, manyTypes.FindProperty("NullableTimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeOnlyArrayColumnBase, manyTypes.FindProperty("NullableTimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanColumnBase, manyTypes.FindProperty("NullableTimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableTimeSpanArrayColumnBase, manyTypes.FindProperty("NullableTimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ColumnBase, manyTypes.FindProperty("NullableUInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt16ArrayColumnBase, manyTypes.FindProperty("NullableUInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ColumnBase, manyTypes.FindProperty("NullableUInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt32ArrayColumnBase, manyTypes.FindProperty("NullableUInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ColumnBase, manyTypes.FindProperty("NullableUInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt64ArrayColumnBase, manyTypes.FindProperty("NullableUInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ColumnBase, manyTypes.FindProperty("NullableUInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUInt8ArrayColumnBase, manyTypes.FindProperty("NullableUInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriColumnBase, manyTypes.FindProperty("NullableUri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)nullableUriArrayColumnBase, manyTypes.FindProperty("NullableUriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressColumnBase, manyTypes.FindProperty("PhysicalAddress")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressArrayColumnBase, manyTypes.FindProperty("PhysicalAddressArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressToBytesConverterPropertyColumnBase, manyTypes.FindProperty("PhysicalAddressToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)physicalAddressToStringConverterPropertyColumnBase, manyTypes.FindProperty("PhysicalAddressToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringColumnBase, manyTypes.FindProperty("String")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringArrayColumnBase, manyTypes.FindProperty("StringArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToBoolConverterPropertyColumnBase, manyTypes.FindProperty("StringToBoolConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToBytesConverterPropertyColumnBase, manyTypes.FindProperty("StringToBytesConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToCharConverterPropertyColumnBase, manyTypes.FindProperty("StringToCharConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToDateOnlyConverterPropertyColumnBase, manyTypes.FindProperty("StringToDateOnlyConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToDateTimeConverterPropertyColumnBase, manyTypes.FindProperty("StringToDateTimeConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToDateTimeOffsetConverterPropertyColumnBase, manyTypes.FindProperty("StringToDateTimeOffsetConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToDecimalNumberConverterPropertyColumnBase, manyTypes.FindProperty("StringToDecimalNumberConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToDoubleNumberConverterPropertyColumnBase, manyTypes.FindProperty("StringToDoubleNumberConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToEnumConverterPropertyColumnBase, manyTypes.FindProperty("StringToEnumConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToGuidConverterPropertyColumnBase, manyTypes.FindProperty("StringToGuidConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToIntNumberConverterPropertyColumnBase, manyTypes.FindProperty("StringToIntNumberConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToTimeOnlyConverterPropertyColumnBase, manyTypes.FindProperty("StringToTimeOnlyConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToTimeSpanConverterPropertyColumnBase, manyTypes.FindProperty("StringToTimeSpanConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)stringToUriConverterPropertyColumnBase, manyTypes.FindProperty("StringToUriConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyColumnBase, manyTypes.FindProperty("TimeOnly")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyArrayColumnBase, manyTypes.FindProperty("TimeOnlyArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyToStringConverterPropertyColumnBase, manyTypes.FindProperty("TimeOnlyToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeOnlyToTicksConverterPropertyColumnBase, manyTypes.FindProperty("TimeOnlyToTicksConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanColumnBase, manyTypes.FindProperty("TimeSpan")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanArrayColumnBase, manyTypes.FindProperty("TimeSpanArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanToStringConverterPropertyColumnBase, manyTypes.FindProperty("TimeSpanToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)timeSpanToTicksConverterPropertyColumnBase, manyTypes.FindProperty("TimeSpanToTicksConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ColumnBase, manyTypes.FindProperty("UInt16")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt16ArrayColumnBase, manyTypes.FindProperty("UInt16Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ColumnBase, manyTypes.FindProperty("UInt32")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt32ArrayColumnBase, manyTypes.FindProperty("UInt32Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ColumnBase, manyTypes.FindProperty("UInt64")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt64ArrayColumnBase, manyTypes.FindProperty("UInt64Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ColumnBase, manyTypes.FindProperty("UInt8")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uInt8ArrayColumnBase, manyTypes.FindProperty("UInt8Array")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriColumnBase, manyTypes.FindProperty("Uri")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriArrayColumnBase, manyTypes.FindProperty("UriArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)uriToStringConverterPropertyColumnBase, manyTypes.FindProperty("UriToStringConverterProperty")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestManyTypesMappingBase);

            var tableMappings2 = new List<TableMapping>();
            manyTypes.SetRuntimeAnnotation("Relational:TableMappings", tableMappings2);
            var manyTypesTable = new Table("ManyTypes", null, relationalModel);
            var idColumn1 = new Column("Id", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Id", idColumn1);
            var boolColumn = new Column("Bool", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Bool", boolColumn);
            var boolArrayColumn = new Column("BoolArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
            var boolToStringConverterPropertyColumn = new Column("BoolToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("BoolToStringConverterProperty", boolToStringConverterPropertyColumn);
            var boolToTwoValuesConverterPropertyColumn = new Column("BoolToTwoValuesConverterProperty", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("BoolToTwoValuesConverterProperty", boolToTwoValuesConverterPropertyColumn);
            var boolToZeroOneConverterPropertyColumn = new Column("BoolToZeroOneConverterProperty", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("BoolToZeroOneConverterProperty", boolToZeroOneConverterPropertyColumn);
            var bytesColumn = new Column("Bytes", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Bytes", bytesColumn);
            var bytesArrayColumn = new Column("BytesArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
            var bytesToStringConverterPropertyColumn = new Column("BytesToStringConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("BytesToStringConverterProperty", bytesToStringConverterPropertyColumn);
            var castingConverterPropertyColumn = new Column("CastingConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("CastingConverterProperty", castingConverterPropertyColumn);
            var charColumn = new Column("Char", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Char", charColumn);
            var charArrayColumn = new Column("CharArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("CharArray", charArrayColumn);
            var charToStringConverterPropertyColumn = new Column("CharToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("CharToStringConverterProperty", charToStringConverterPropertyColumn);
            var dateOnlyColumn = new Column("DateOnly", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
            var dateOnlyArrayColumn = new Column("DateOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
            var dateOnlyToStringConverterPropertyColumn = new Column("DateOnlyToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateOnlyToStringConverterProperty", dateOnlyToStringConverterPropertyColumn);
            var dateTimeColumn = new Column("DateTime", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
            var dateTimeArrayColumn = new Column("DateTimeArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
            var dateTimeOffsetToBinaryConverterPropertyColumn = new Column("DateTimeOffsetToBinaryConverterProperty", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("DateTimeOffsetToBinaryConverterProperty", dateTimeOffsetToBinaryConverterPropertyColumn);
            var dateTimeOffsetToBytesConverterPropertyColumn = new Column("DateTimeOffsetToBytesConverterProperty", "BLOB", manyTypesTable);
            manyTypesTable.Columns.Add("DateTimeOffsetToBytesConverterProperty", dateTimeOffsetToBytesConverterPropertyColumn);
            var dateTimeOffsetToStringConverterPropertyColumn = new Column("DateTimeOffsetToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateTimeOffsetToStringConverterProperty", dateTimeOffsetToStringConverterPropertyColumn);
            var dateTimeToBinaryConverterPropertyColumn = new Column("DateTimeToBinaryConverterProperty", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("DateTimeToBinaryConverterProperty", dateTimeToBinaryConverterPropertyColumn);
            var dateTimeToStringConverterPropertyColumn = new Column("DateTimeToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateTimeToStringConverterProperty", dateTimeToStringConverterPropertyColumn);
            var dateTimeToTicksConverterPropertyColumn = new Column("DateTimeToTicksConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DateTimeToTicksConverterProperty", dateTimeToTicksConverterPropertyColumn);
            var decimalColumn = new Column("Decimal", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Decimal", decimalColumn);
            var decimalArrayColumn = new Column("DecimalArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
            var decimalNumberToBytesConverterPropertyColumn = new Column("DecimalNumberToBytesConverterProperty", "BLOB", manyTypesTable);
            manyTypesTable.Columns.Add("DecimalNumberToBytesConverterProperty", decimalNumberToBytesConverterPropertyColumn);
            var decimalNumberToStringConverterPropertyColumn = new Column("DecimalNumberToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DecimalNumberToStringConverterProperty", decimalNumberToStringConverterPropertyColumn);
            var doubleColumn = new Column("Double", "REAL", manyTypesTable);
            manyTypesTable.Columns.Add("Double", doubleColumn);
            var doubleArrayColumn = new Column("DoubleArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
            var doubleNumberToBytesConverterPropertyColumn = new Column("DoubleNumberToBytesConverterProperty", "BLOB", manyTypesTable);
            manyTypesTable.Columns.Add("DoubleNumberToBytesConverterProperty", doubleNumberToBytesConverterPropertyColumn);
            var doubleNumberToStringConverterPropertyColumn = new Column("DoubleNumberToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("DoubleNumberToStringConverterProperty", doubleNumberToStringConverterPropertyColumn);
            var enum16Column = new Column("Enum16", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Enum16", enum16Column);
            var enum16ArrayColumn = new Column("Enum16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum16Array", enum16ArrayColumn);
            var enum16AsStringColumn = new Column("Enum16AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Enum16AsString", enum16AsStringColumn);
            var enum16AsStringArrayColumn = new Column("Enum16AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum16AsStringArray", enum16AsStringArrayColumn);
            var enum16AsStringCollectionColumn = new Column("Enum16AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum16AsStringCollection", enum16AsStringCollectionColumn);
            var enum16CollectionColumn = new Column("Enum16Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum16Collection", enum16CollectionColumn);
            var enum32Column = new Column("Enum32", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Enum32", enum32Column);
            var enum32ArrayColumn = new Column("Enum32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum32Array", enum32ArrayColumn);
            var enum32AsStringColumn = new Column("Enum32AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Enum32AsString", enum32AsStringColumn);
            var enum32AsStringArrayColumn = new Column("Enum32AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum32AsStringArray", enum32AsStringArrayColumn);
            var enum32AsStringCollectionColumn = new Column("Enum32AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum32AsStringCollection", enum32AsStringCollectionColumn);
            var enum32CollectionColumn = new Column("Enum32Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum32Collection", enum32CollectionColumn);
            var enum64Column = new Column("Enum64", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Enum64", enum64Column);
            var enum64ArrayColumn = new Column("Enum64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum64Array", enum64ArrayColumn);
            var enum64AsStringColumn = new Column("Enum64AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Enum64AsString", enum64AsStringColumn);
            var enum64AsStringArrayColumn = new Column("Enum64AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum64AsStringArray", enum64AsStringArrayColumn);
            var enum64AsStringCollectionColumn = new Column("Enum64AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum64AsStringCollection", enum64AsStringCollectionColumn);
            var enum64CollectionColumn = new Column("Enum64Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum64Collection", enum64CollectionColumn);
            var enum8Column = new Column("Enum8", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Enum8", enum8Column);
            var enum8ArrayColumn = new Column("Enum8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum8Array", enum8ArrayColumn);
            var enum8AsStringColumn = new Column("Enum8AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Enum8AsString", enum8AsStringColumn);
            var enum8AsStringArrayColumn = new Column("Enum8AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum8AsStringArray", enum8AsStringArrayColumn);
            var enum8AsStringCollectionColumn = new Column("Enum8AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum8AsStringCollection", enum8AsStringCollectionColumn);
            var enum8CollectionColumn = new Column("Enum8Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Enum8Collection", enum8CollectionColumn);
            var enumToNumberConverterPropertyColumn = new Column("EnumToNumberConverterProperty", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("EnumToNumberConverterProperty", enumToNumberConverterPropertyColumn);
            var enumToStringConverterPropertyColumn = new Column("EnumToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("EnumToStringConverterProperty", enumToStringConverterPropertyColumn);
            var enumU16Column = new Column("EnumU16", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU16", enumU16Column);
            var enumU16ArrayColumn = new Column("EnumU16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU16Array", enumU16ArrayColumn);
            var enumU16AsStringColumn = new Column("EnumU16AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU16AsString", enumU16AsStringColumn);
            var enumU16AsStringArrayColumn = new Column("EnumU16AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU16AsStringArray", enumU16AsStringArrayColumn);
            var enumU16AsStringCollectionColumn = new Column("EnumU16AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU16AsStringCollection", enumU16AsStringCollectionColumn);
            var enumU16CollectionColumn = new Column("EnumU16Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU16Collection", enumU16CollectionColumn);
            var enumU32Column = new Column("EnumU32", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU32", enumU32Column);
            var enumU32ArrayColumn = new Column("EnumU32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU32Array", enumU32ArrayColumn);
            var enumU32AsStringColumn = new Column("EnumU32AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU32AsString", enumU32AsStringColumn);
            var enumU32AsStringArrayColumn = new Column("EnumU32AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU32AsStringArray", enumU32AsStringArrayColumn);
            var enumU32AsStringCollectionColumn = new Column("EnumU32AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU32AsStringCollection", enumU32AsStringCollectionColumn);
            var enumU32CollectionColumn = new Column("EnumU32Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU32Collection", enumU32CollectionColumn);
            var enumU64Column = new Column("EnumU64", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU64", enumU64Column);
            var enumU64ArrayColumn = new Column("EnumU64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU64Array", enumU64ArrayColumn);
            var enumU64AsStringColumn = new Column("EnumU64AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU64AsString", enumU64AsStringColumn);
            var enumU64AsStringArrayColumn = new Column("EnumU64AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU64AsStringArray", enumU64AsStringArrayColumn);
            var enumU64AsStringCollectionColumn = new Column("EnumU64AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU64AsStringCollection", enumU64AsStringCollectionColumn);
            var enumU64CollectionColumn = new Column("EnumU64Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU64Collection", enumU64CollectionColumn);
            var enumU8Column = new Column("EnumU8", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU8", enumU8Column);
            var enumU8ArrayColumn = new Column("EnumU8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU8Array", enumU8ArrayColumn);
            var enumU8AsStringColumn = new Column("EnumU8AsString", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("EnumU8AsString", enumU8AsStringColumn);
            var enumU8AsStringArrayColumn = new Column("EnumU8AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU8AsStringArray", enumU8AsStringArrayColumn);
            var enumU8AsStringCollectionColumn = new Column("EnumU8AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU8AsStringCollection", enumU8AsStringCollectionColumn);
            var enumU8CollectionColumn = new Column("EnumU8Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("EnumU8Collection", enumU8CollectionColumn);
            var floatColumn = new Column("Float", "REAL", manyTypesTable);
            manyTypesTable.Columns.Add("Float", floatColumn);
            var floatArrayColumn = new Column("FloatArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
            var guidColumn = new Column("Guid", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("Guid", guidColumn);
            var guidArrayColumn = new Column("GuidArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
            var guidToBytesConverterPropertyColumn = new Column("GuidToBytesConverterProperty", "BLOB", manyTypesTable);
            manyTypesTable.Columns.Add("GuidToBytesConverterProperty", guidToBytesConverterPropertyColumn);
            var guidToStringConverterPropertyColumn = new Column("GuidToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("GuidToStringConverterProperty", guidToStringConverterPropertyColumn);
            var iPAddressColumn = new Column("IPAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
            var iPAddressArrayColumn = new Column("IPAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
            var iPAddressToBytesConverterPropertyColumn = new Column("IPAddressToBytesConverterProperty", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddressToBytesConverterProperty", iPAddressToBytesConverterPropertyColumn);
            var iPAddressToStringConverterPropertyColumn = new Column("IPAddressToStringConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("IPAddressToStringConverterProperty", iPAddressToStringConverterPropertyColumn);
            var int16Column = new Column("Int16", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int16", int16Column);
            var int16ArrayColumn = new Column("Int16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
            var int32Column = new Column("Int32", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int32", int32Column);
            var int32ArrayColumn = new Column("Int32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
            var int64Column = new Column("Int64", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int64", int64Column);
            var int64ArrayColumn = new Column("Int64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
            var int8Column = new Column("Int8", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("Int8", int8Column);
            var int8ArrayColumn = new Column("Int8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
            var intNumberToBytesConverterPropertyColumn = new Column("IntNumberToBytesConverterProperty", "BLOB", manyTypesTable);
            manyTypesTable.Columns.Add("IntNumberToBytesConverterProperty", intNumberToBytesConverterPropertyColumn);
            var intNumberToStringConverterPropertyColumn = new Column("IntNumberToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("IntNumberToStringConverterProperty", intNumberToStringConverterPropertyColumn);
            var nullIntToNullStringConverterPropertyColumn = new Column("NullIntToNullStringConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullIntToNullStringConverterProperty", nullIntToNullStringConverterPropertyColumn);
            var nullableBoolColumn = new Column("NullableBool", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
            var nullableBoolArrayColumn = new Column("NullableBoolArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
            var nullableBytesColumn = new Column("NullableBytes", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
            var nullableBytesArrayColumn = new Column("NullableBytesArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
            var nullableCharColumn = new Column("NullableChar", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
            var nullableCharArrayColumn = new Column("NullableCharArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
            var nullableDateOnlyColumn = new Column("NullableDateOnly", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
            var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
            var nullableDateTimeColumn = new Column("NullableDateTime", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
            var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
            var nullableDecimalColumn = new Column("NullableDecimal", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
            var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
            var nullableDoubleColumn = new Column("NullableDouble", "REAL", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
            var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
            var nullableEnum16Column = new Column("NullableEnum16", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum16", nullableEnum16Column);
            var nullableEnum16ArrayColumn = new Column("NullableEnum16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum16Array", nullableEnum16ArrayColumn);
            var nullableEnum16AsStringColumn = new Column("NullableEnum16AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum16AsString", nullableEnum16AsStringColumn);
            var nullableEnum16AsStringArrayColumn = new Column("NullableEnum16AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum16AsStringArray", nullableEnum16AsStringArrayColumn);
            var nullableEnum16AsStringCollectionColumn = new Column("NullableEnum16AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum16AsStringCollection", nullableEnum16AsStringCollectionColumn);
            var nullableEnum16CollectionColumn = new Column("NullableEnum16Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum16Collection", nullableEnum16CollectionColumn);
            var nullableEnum32Column = new Column("NullableEnum32", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum32", nullableEnum32Column);
            var nullableEnum32ArrayColumn = new Column("NullableEnum32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum32Array", nullableEnum32ArrayColumn);
            var nullableEnum32AsStringColumn = new Column("NullableEnum32AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum32AsString", nullableEnum32AsStringColumn);
            var nullableEnum32AsStringArrayColumn = new Column("NullableEnum32AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum32AsStringArray", nullableEnum32AsStringArrayColumn);
            var nullableEnum32AsStringCollectionColumn = new Column("NullableEnum32AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum32AsStringCollection", nullableEnum32AsStringCollectionColumn);
            var nullableEnum32CollectionColumn = new Column("NullableEnum32Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum32Collection", nullableEnum32CollectionColumn);
            var nullableEnum64Column = new Column("NullableEnum64", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum64", nullableEnum64Column);
            var nullableEnum64ArrayColumn = new Column("NullableEnum64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum64Array", nullableEnum64ArrayColumn);
            var nullableEnum64AsStringColumn = new Column("NullableEnum64AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum64AsString", nullableEnum64AsStringColumn);
            var nullableEnum64AsStringArrayColumn = new Column("NullableEnum64AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum64AsStringArray", nullableEnum64AsStringArrayColumn);
            var nullableEnum64AsStringCollectionColumn = new Column("NullableEnum64AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum64AsStringCollection", nullableEnum64AsStringCollectionColumn);
            var nullableEnum64CollectionColumn = new Column("NullableEnum64Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum64Collection", nullableEnum64CollectionColumn);
            var nullableEnum8Column = new Column("NullableEnum8", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum8", nullableEnum8Column);
            var nullableEnum8ArrayColumn = new Column("NullableEnum8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum8Array", nullableEnum8ArrayColumn);
            var nullableEnum8AsStringColumn = new Column("NullableEnum8AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum8AsString", nullableEnum8AsStringColumn);
            var nullableEnum8AsStringArrayColumn = new Column("NullableEnum8AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum8AsStringArray", nullableEnum8AsStringArrayColumn);
            var nullableEnum8AsStringCollectionColumn = new Column("NullableEnum8AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum8AsStringCollection", nullableEnum8AsStringCollectionColumn);
            var nullableEnum8CollectionColumn = new Column("NullableEnum8Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnum8Collection", nullableEnum8CollectionColumn);
            var nullableEnumU16Column = new Column("NullableEnumU16", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU16", nullableEnumU16Column);
            var nullableEnumU16ArrayColumn = new Column("NullableEnumU16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU16Array", nullableEnumU16ArrayColumn);
            var nullableEnumU16AsStringColumn = new Column("NullableEnumU16AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU16AsString", nullableEnumU16AsStringColumn);
            var nullableEnumU16AsStringArrayColumn = new Column("NullableEnumU16AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU16AsStringArray", nullableEnumU16AsStringArrayColumn);
            var nullableEnumU16AsStringCollectionColumn = new Column("NullableEnumU16AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU16AsStringCollection", nullableEnumU16AsStringCollectionColumn);
            var nullableEnumU16CollectionColumn = new Column("NullableEnumU16Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU16Collection", nullableEnumU16CollectionColumn);
            var nullableEnumU32Column = new Column("NullableEnumU32", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU32", nullableEnumU32Column);
            var nullableEnumU32ArrayColumn = new Column("NullableEnumU32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU32Array", nullableEnumU32ArrayColumn);
            var nullableEnumU32AsStringColumn = new Column("NullableEnumU32AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU32AsString", nullableEnumU32AsStringColumn);
            var nullableEnumU32AsStringArrayColumn = new Column("NullableEnumU32AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU32AsStringArray", nullableEnumU32AsStringArrayColumn);
            var nullableEnumU32AsStringCollectionColumn = new Column("NullableEnumU32AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU32AsStringCollection", nullableEnumU32AsStringCollectionColumn);
            var nullableEnumU32CollectionColumn = new Column("NullableEnumU32Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU32Collection", nullableEnumU32CollectionColumn);
            var nullableEnumU64Column = new Column("NullableEnumU64", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU64", nullableEnumU64Column);
            var nullableEnumU64ArrayColumn = new Column("NullableEnumU64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU64Array", nullableEnumU64ArrayColumn);
            var nullableEnumU64AsStringColumn = new Column("NullableEnumU64AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU64AsString", nullableEnumU64AsStringColumn);
            var nullableEnumU64AsStringArrayColumn = new Column("NullableEnumU64AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU64AsStringArray", nullableEnumU64AsStringArrayColumn);
            var nullableEnumU64AsStringCollectionColumn = new Column("NullableEnumU64AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU64AsStringCollection", nullableEnumU64AsStringCollectionColumn);
            var nullableEnumU64CollectionColumn = new Column("NullableEnumU64Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU64Collection", nullableEnumU64CollectionColumn);
            var nullableEnumU8Column = new Column("NullableEnumU8", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU8", nullableEnumU8Column);
            var nullableEnumU8ArrayColumn = new Column("NullableEnumU8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU8Array", nullableEnumU8ArrayColumn);
            var nullableEnumU8AsStringColumn = new Column("NullableEnumU8AsString", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU8AsString", nullableEnumU8AsStringColumn);
            var nullableEnumU8AsStringArrayColumn = new Column("NullableEnumU8AsStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU8AsStringArray", nullableEnumU8AsStringArrayColumn);
            var nullableEnumU8AsStringCollectionColumn = new Column("NullableEnumU8AsStringCollection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU8AsStringCollection", nullableEnumU8AsStringCollectionColumn);
            var nullableEnumU8CollectionColumn = new Column("NullableEnumU8Collection", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableEnumU8Collection", nullableEnumU8CollectionColumn);
            var nullableFloatColumn = new Column("NullableFloat", "REAL", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
            var nullableFloatArrayColumn = new Column("NullableFloatArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
            var nullableGuidColumn = new Column("NullableGuid", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
            var nullableGuidArrayColumn = new Column("NullableGuidArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
            var nullableIPAddressColumn = new Column("NullableIPAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
            var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
            var nullableInt16Column = new Column("NullableInt16", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
            var nullableInt16ArrayColumn = new Column("NullableInt16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
            var nullableInt32Column = new Column("NullableInt32", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
            var nullableInt32ArrayColumn = new Column("NullableInt32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
            var nullableInt64Column = new Column("NullableInt64", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
            var nullableInt64ArrayColumn = new Column("NullableInt64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
            var nullableInt8Column = new Column("NullableInt8", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
            var nullableInt8ArrayColumn = new Column("NullableInt8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
            var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
            var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
            var nullableStringColumn = new Column("NullableString", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
            var nullableStringArrayColumn = new Column("NullableStringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
            var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
            var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
            var nullableTimeSpanColumn = new Column("NullableTimeSpan", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
            var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
            var nullableUInt16Column = new Column("NullableUInt16", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
            var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
            var nullableUInt32Column = new Column("NullableUInt32", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
            var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
            var nullableUInt64Column = new Column("NullableUInt64", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
            var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
            var nullableUInt8Column = new Column("NullableUInt8", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
            var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
            var nullableUriColumn = new Column("NullableUri", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
            var nullableUriArrayColumn = new Column("NullableUriArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
            var physicalAddressColumn = new Column("PhysicalAddress", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
            var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
            var physicalAddressToBytesConverterPropertyColumn = new Column("PhysicalAddressToBytesConverterProperty", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddressToBytesConverterProperty", physicalAddressToBytesConverterPropertyColumn);
            var physicalAddressToStringConverterPropertyColumn = new Column("PhysicalAddressToStringConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("PhysicalAddressToStringConverterProperty", physicalAddressToStringConverterPropertyColumn);
            var stringColumn = new Column("String", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("String", stringColumn);
            var stringArrayColumn = new Column("StringArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
            var stringToBoolConverterPropertyColumn = new Column("StringToBoolConverterProperty", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToBoolConverterProperty", stringToBoolConverterPropertyColumn);
            var stringToBytesConverterPropertyColumn = new Column("StringToBytesConverterProperty", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToBytesConverterProperty", stringToBytesConverterPropertyColumn);
            var stringToCharConverterPropertyColumn = new Column("StringToCharConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToCharConverterProperty", stringToCharConverterPropertyColumn);
            var stringToDateOnlyConverterPropertyColumn = new Column("StringToDateOnlyConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToDateOnlyConverterProperty", stringToDateOnlyConverterPropertyColumn);
            var stringToDateTimeConverterPropertyColumn = new Column("StringToDateTimeConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToDateTimeConverterProperty", stringToDateTimeConverterPropertyColumn);
            var stringToDateTimeOffsetConverterPropertyColumn = new Column("StringToDateTimeOffsetConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToDateTimeOffsetConverterProperty", stringToDateTimeOffsetConverterPropertyColumn);
            var stringToDecimalNumberConverterPropertyColumn = new Column("StringToDecimalNumberConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToDecimalNumberConverterProperty", stringToDecimalNumberConverterPropertyColumn);
            var stringToDoubleNumberConverterPropertyColumn = new Column("StringToDoubleNumberConverterProperty", "REAL", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToDoubleNumberConverterProperty", stringToDoubleNumberConverterPropertyColumn);
            var stringToEnumConverterPropertyColumn = new Column("StringToEnumConverterProperty", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToEnumConverterProperty", stringToEnumConverterPropertyColumn);
            var stringToGuidConverterPropertyColumn = new Column("StringToGuidConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToGuidConverterProperty", stringToGuidConverterPropertyColumn);
            var stringToIntNumberConverterPropertyColumn = new Column("StringToIntNumberConverterProperty", "INTEGER", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToIntNumberConverterProperty", stringToIntNumberConverterPropertyColumn);
            var stringToTimeOnlyConverterPropertyColumn = new Column("StringToTimeOnlyConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToTimeOnlyConverterProperty", stringToTimeOnlyConverterPropertyColumn);
            var stringToTimeSpanConverterPropertyColumn = new Column("StringToTimeSpanConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToTimeSpanConverterProperty", stringToTimeSpanConverterPropertyColumn);
            var stringToUriConverterPropertyColumn = new Column("StringToUriConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("StringToUriConverterProperty", stringToUriConverterPropertyColumn);
            var timeOnlyColumn = new Column("TimeOnly", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
            var timeOnlyArrayColumn = new Column("TimeOnlyArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
            var timeOnlyToStringConverterPropertyColumn = new Column("TimeOnlyToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("TimeOnlyToStringConverterProperty", timeOnlyToStringConverterPropertyColumn);
            var timeOnlyToTicksConverterPropertyColumn = new Column("TimeOnlyToTicksConverterProperty", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("TimeOnlyToTicksConverterProperty", timeOnlyToTicksConverterPropertyColumn);
            var timeSpanColumn = new Column("TimeSpan", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
            var timeSpanArrayColumn = new Column("TimeSpanArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
            var timeSpanToStringConverterPropertyColumn = new Column("TimeSpanToStringConverterProperty", "TEXT", manyTypesTable);
            manyTypesTable.Columns.Add("TimeSpanToStringConverterProperty", timeSpanToStringConverterPropertyColumn);
            var timeSpanToTicksConverterPropertyColumn = new Column("TimeSpanToTicksConverterProperty", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("TimeSpanToTicksConverterProperty", timeSpanToTicksConverterPropertyColumn);
            var uInt16Column = new Column("UInt16", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt16", uInt16Column);
            var uInt16ArrayColumn = new Column("UInt16Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
            var uInt32Column = new Column("UInt32", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt32", uInt32Column);
            var uInt32ArrayColumn = new Column("UInt32Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
            var uInt64Column = new Column("UInt64", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt64", uInt64Column);
            var uInt64ArrayColumn = new Column("UInt64Array", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
            var uInt8Column = new Column("UInt8", "INTEGER", manyTypesTable);
            manyTypesTable.Columns.Add("UInt8", uInt8Column);
            var uInt8ArrayColumn = new Column("UInt8Array", "BLOB", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
            var uriColumn = new Column("Uri", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("Uri", uriColumn);
            var uriArrayColumn = new Column("UriArray", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
            var uriToStringConverterPropertyColumn = new Column("UriToStringConverterProperty", "TEXT", manyTypesTable)
            {
                IsNullable = true
            };
            manyTypesTable.Columns.Add("UriToStringConverterProperty", uriToStringConverterPropertyColumn);
            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn1 });
            manyTypesTable.PrimaryKey = pK_ManyTypes;
            var pK_ManyTypesUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                new[] { "Id" });
            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesUc).Add(pK_ManyTypes);
            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
            relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
            var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, true);
            manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
            tableMappings2.Add(manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(idColumn1, manyTypes.FindProperty("Id")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolColumn, manyTypes.FindProperty("Bool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolArrayColumn, manyTypes.FindProperty("BoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolToStringConverterPropertyColumn, manyTypes.FindProperty("BoolToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolToTwoValuesConverterPropertyColumn, manyTypes.FindProperty("BoolToTwoValuesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(boolToZeroOneConverterPropertyColumn, manyTypes.FindProperty("BoolToZeroOneConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesColumn, manyTypes.FindProperty("Bytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesArrayColumn, manyTypes.FindProperty("BytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(bytesToStringConverterPropertyColumn, manyTypes.FindProperty("BytesToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(castingConverterPropertyColumn, manyTypes.FindProperty("CastingConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charColumn, manyTypes.FindProperty("Char")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charArrayColumn, manyTypes.FindProperty("CharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(charToStringConverterPropertyColumn, manyTypes.FindProperty("CharToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyColumn, manyTypes.FindProperty("DateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyArrayColumn, manyTypes.FindProperty("DateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateOnlyToStringConverterPropertyColumn, manyTypes.FindProperty("DateOnlyToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeColumn, manyTypes.FindProperty("DateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeArrayColumn, manyTypes.FindProperty("DateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeOffsetToBinaryConverterPropertyColumn, manyTypes.FindProperty("DateTimeOffsetToBinaryConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeOffsetToBytesConverterPropertyColumn, manyTypes.FindProperty("DateTimeOffsetToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeOffsetToStringConverterPropertyColumn, manyTypes.FindProperty("DateTimeOffsetToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeToBinaryConverterPropertyColumn, manyTypes.FindProperty("DateTimeToBinaryConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeToStringConverterPropertyColumn, manyTypes.FindProperty("DateTimeToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(dateTimeToTicksConverterPropertyColumn, manyTypes.FindProperty("DateTimeToTicksConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalColumn, manyTypes.FindProperty("Decimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalArrayColumn, manyTypes.FindProperty("DecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalNumberToBytesConverterPropertyColumn, manyTypes.FindProperty("DecimalNumberToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(decimalNumberToStringConverterPropertyColumn, manyTypes.FindProperty("DecimalNumberToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleColumn, manyTypes.FindProperty("Double")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleArrayColumn, manyTypes.FindProperty("DoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleNumberToBytesConverterPropertyColumn, manyTypes.FindProperty("DoubleNumberToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(doubleNumberToStringConverterPropertyColumn, manyTypes.FindProperty("DoubleNumberToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum16Column, manyTypes.FindProperty("Enum16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum16ArrayColumn, manyTypes.FindProperty("Enum16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum16AsStringColumn, manyTypes.FindProperty("Enum16AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum16AsStringArrayColumn, manyTypes.FindProperty("Enum16AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum16AsStringCollectionColumn, manyTypes.FindProperty("Enum16AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum16CollectionColumn, manyTypes.FindProperty("Enum16Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum32Column, manyTypes.FindProperty("Enum32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum32ArrayColumn, manyTypes.FindProperty("Enum32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum32AsStringColumn, manyTypes.FindProperty("Enum32AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum32AsStringArrayColumn, manyTypes.FindProperty("Enum32AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum32AsStringCollectionColumn, manyTypes.FindProperty("Enum32AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum32CollectionColumn, manyTypes.FindProperty("Enum32Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum64Column, manyTypes.FindProperty("Enum64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum64ArrayColumn, manyTypes.FindProperty("Enum64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum64AsStringColumn, manyTypes.FindProperty("Enum64AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum64AsStringArrayColumn, manyTypes.FindProperty("Enum64AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum64AsStringCollectionColumn, manyTypes.FindProperty("Enum64AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum64CollectionColumn, manyTypes.FindProperty("Enum64Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum8Column, manyTypes.FindProperty("Enum8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum8ArrayColumn, manyTypes.FindProperty("Enum8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum8AsStringColumn, manyTypes.FindProperty("Enum8AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum8AsStringArrayColumn, manyTypes.FindProperty("Enum8AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum8AsStringCollectionColumn, manyTypes.FindProperty("Enum8AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enum8CollectionColumn, manyTypes.FindProperty("Enum8Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumToNumberConverterPropertyColumn, manyTypes.FindProperty("EnumToNumberConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumToStringConverterPropertyColumn, manyTypes.FindProperty("EnumToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU16Column, manyTypes.FindProperty("EnumU16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU16ArrayColumn, manyTypes.FindProperty("EnumU16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU16AsStringColumn, manyTypes.FindProperty("EnumU16AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU16AsStringArrayColumn, manyTypes.FindProperty("EnumU16AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU16AsStringCollectionColumn, manyTypes.FindProperty("EnumU16AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU16CollectionColumn, manyTypes.FindProperty("EnumU16Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU32Column, manyTypes.FindProperty("EnumU32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU32ArrayColumn, manyTypes.FindProperty("EnumU32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU32AsStringColumn, manyTypes.FindProperty("EnumU32AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU32AsStringArrayColumn, manyTypes.FindProperty("EnumU32AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU32AsStringCollectionColumn, manyTypes.FindProperty("EnumU32AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU32CollectionColumn, manyTypes.FindProperty("EnumU32Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU64Column, manyTypes.FindProperty("EnumU64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU64ArrayColumn, manyTypes.FindProperty("EnumU64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU64AsStringColumn, manyTypes.FindProperty("EnumU64AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU64AsStringArrayColumn, manyTypes.FindProperty("EnumU64AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU64AsStringCollectionColumn, manyTypes.FindProperty("EnumU64AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU64CollectionColumn, manyTypes.FindProperty("EnumU64Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU8Column, manyTypes.FindProperty("EnumU8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU8ArrayColumn, manyTypes.FindProperty("EnumU8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU8AsStringColumn, manyTypes.FindProperty("EnumU8AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU8AsStringArrayColumn, manyTypes.FindProperty("EnumU8AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU8AsStringCollectionColumn, manyTypes.FindProperty("EnumU8AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(enumU8CollectionColumn, manyTypes.FindProperty("EnumU8Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatColumn, manyTypes.FindProperty("Float")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(floatArrayColumn, manyTypes.FindProperty("FloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidColumn, manyTypes.FindProperty("Guid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidArrayColumn, manyTypes.FindProperty("GuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidToBytesConverterPropertyColumn, manyTypes.FindProperty("GuidToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(guidToStringConverterPropertyColumn, manyTypes.FindProperty("GuidToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressColumn, manyTypes.FindProperty("IPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressArrayColumn, manyTypes.FindProperty("IPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressToBytesConverterPropertyColumn, manyTypes.FindProperty("IPAddressToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(iPAddressToStringConverterPropertyColumn, manyTypes.FindProperty("IPAddressToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16Column, manyTypes.FindProperty("Int16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int16ArrayColumn, manyTypes.FindProperty("Int16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32Column, manyTypes.FindProperty("Int32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int32ArrayColumn, manyTypes.FindProperty("Int32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64Column, manyTypes.FindProperty("Int64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int64ArrayColumn, manyTypes.FindProperty("Int64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8Column, manyTypes.FindProperty("Int8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(int8ArrayColumn, manyTypes.FindProperty("Int8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(intNumberToBytesConverterPropertyColumn, manyTypes.FindProperty("IntNumberToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(intNumberToStringConverterPropertyColumn, manyTypes.FindProperty("IntNumberToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullIntToNullStringConverterPropertyColumn, manyTypes.FindProperty("NullIntToNullStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolColumn, manyTypes.FindProperty("NullableBool")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBoolArrayColumn, manyTypes.FindProperty("NullableBoolArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesColumn, manyTypes.FindProperty("NullableBytes")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableBytesArrayColumn, manyTypes.FindProperty("NullableBytesArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharColumn, manyTypes.FindProperty("NullableChar")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableCharArrayColumn, manyTypes.FindProperty("NullableCharArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyColumn, manyTypes.FindProperty("NullableDateOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateOnlyArrayColumn, manyTypes.FindProperty("NullableDateOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeColumn, manyTypes.FindProperty("NullableDateTime")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDateTimeArrayColumn, manyTypes.FindProperty("NullableDateTimeArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalColumn, manyTypes.FindProperty("NullableDecimal")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDecimalArrayColumn, manyTypes.FindProperty("NullableDecimalArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleColumn, manyTypes.FindProperty("NullableDouble")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableDoubleArrayColumn, manyTypes.FindProperty("NullableDoubleArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum16Column, manyTypes.FindProperty("NullableEnum16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum16ArrayColumn, manyTypes.FindProperty("NullableEnum16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum16AsStringColumn, manyTypes.FindProperty("NullableEnum16AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum16AsStringArrayColumn, manyTypes.FindProperty("NullableEnum16AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum16AsStringCollectionColumn, manyTypes.FindProperty("NullableEnum16AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum16CollectionColumn, manyTypes.FindProperty("NullableEnum16Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum32Column, manyTypes.FindProperty("NullableEnum32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum32ArrayColumn, manyTypes.FindProperty("NullableEnum32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum32AsStringColumn, manyTypes.FindProperty("NullableEnum32AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum32AsStringArrayColumn, manyTypes.FindProperty("NullableEnum32AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum32AsStringCollectionColumn, manyTypes.FindProperty("NullableEnum32AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum32CollectionColumn, manyTypes.FindProperty("NullableEnum32Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum64Column, manyTypes.FindProperty("NullableEnum64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum64ArrayColumn, manyTypes.FindProperty("NullableEnum64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum64AsStringColumn, manyTypes.FindProperty("NullableEnum64AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum64AsStringArrayColumn, manyTypes.FindProperty("NullableEnum64AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum64AsStringCollectionColumn, manyTypes.FindProperty("NullableEnum64AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum64CollectionColumn, manyTypes.FindProperty("NullableEnum64Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum8Column, manyTypes.FindProperty("NullableEnum8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum8ArrayColumn, manyTypes.FindProperty("NullableEnum8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum8AsStringColumn, manyTypes.FindProperty("NullableEnum8AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum8AsStringArrayColumn, manyTypes.FindProperty("NullableEnum8AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum8AsStringCollectionColumn, manyTypes.FindProperty("NullableEnum8AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnum8CollectionColumn, manyTypes.FindProperty("NullableEnum8Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU16Column, manyTypes.FindProperty("NullableEnumU16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU16ArrayColumn, manyTypes.FindProperty("NullableEnumU16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU16AsStringColumn, manyTypes.FindProperty("NullableEnumU16AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU16AsStringArrayColumn, manyTypes.FindProperty("NullableEnumU16AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU16AsStringCollectionColumn, manyTypes.FindProperty("NullableEnumU16AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU16CollectionColumn, manyTypes.FindProperty("NullableEnumU16Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU32Column, manyTypes.FindProperty("NullableEnumU32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU32ArrayColumn, manyTypes.FindProperty("NullableEnumU32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU32AsStringColumn, manyTypes.FindProperty("NullableEnumU32AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU32AsStringArrayColumn, manyTypes.FindProperty("NullableEnumU32AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU32AsStringCollectionColumn, manyTypes.FindProperty("NullableEnumU32AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU32CollectionColumn, manyTypes.FindProperty("NullableEnumU32Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU64Column, manyTypes.FindProperty("NullableEnumU64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU64ArrayColumn, manyTypes.FindProperty("NullableEnumU64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU64AsStringColumn, manyTypes.FindProperty("NullableEnumU64AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU64AsStringArrayColumn, manyTypes.FindProperty("NullableEnumU64AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU64AsStringCollectionColumn, manyTypes.FindProperty("NullableEnumU64AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU64CollectionColumn, manyTypes.FindProperty("NullableEnumU64Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU8Column, manyTypes.FindProperty("NullableEnumU8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU8ArrayColumn, manyTypes.FindProperty("NullableEnumU8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU8AsStringColumn, manyTypes.FindProperty("NullableEnumU8AsString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU8AsStringArrayColumn, manyTypes.FindProperty("NullableEnumU8AsStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU8AsStringCollectionColumn, manyTypes.FindProperty("NullableEnumU8AsStringCollection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableEnumU8CollectionColumn, manyTypes.FindProperty("NullableEnumU8Collection")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatColumn, manyTypes.FindProperty("NullableFloat")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableFloatArrayColumn, manyTypes.FindProperty("NullableFloatArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidColumn, manyTypes.FindProperty("NullableGuid")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableGuidArrayColumn, manyTypes.FindProperty("NullableGuidArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressColumn, manyTypes.FindProperty("NullableIPAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableIPAddressArrayColumn, manyTypes.FindProperty("NullableIPAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16Column, manyTypes.FindProperty("NullableInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt16ArrayColumn, manyTypes.FindProperty("NullableInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32Column, manyTypes.FindProperty("NullableInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt32ArrayColumn, manyTypes.FindProperty("NullableInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64Column, manyTypes.FindProperty("NullableInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt64ArrayColumn, manyTypes.FindProperty("NullableInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8Column, manyTypes.FindProperty("NullableInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableInt8ArrayColumn, manyTypes.FindProperty("NullableInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressColumn, manyTypes.FindProperty("NullablePhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullablePhysicalAddressArrayColumn, manyTypes.FindProperty("NullablePhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringColumn, manyTypes.FindProperty("NullableString")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableStringArrayColumn, manyTypes.FindProperty("NullableStringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyColumn, manyTypes.FindProperty("NullableTimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeOnlyArrayColumn, manyTypes.FindProperty("NullableTimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanColumn, manyTypes.FindProperty("NullableTimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableTimeSpanArrayColumn, manyTypes.FindProperty("NullableTimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16Column, manyTypes.FindProperty("NullableUInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt16ArrayColumn, manyTypes.FindProperty("NullableUInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32Column, manyTypes.FindProperty("NullableUInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt32ArrayColumn, manyTypes.FindProperty("NullableUInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64Column, manyTypes.FindProperty("NullableUInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt64ArrayColumn, manyTypes.FindProperty("NullableUInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8Column, manyTypes.FindProperty("NullableUInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUInt8ArrayColumn, manyTypes.FindProperty("NullableUInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriColumn, manyTypes.FindProperty("NullableUri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(nullableUriArrayColumn, manyTypes.FindProperty("NullableUriArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressColumn, manyTypes.FindProperty("PhysicalAddress")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressArrayColumn, manyTypes.FindProperty("PhysicalAddressArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressToBytesConverterPropertyColumn, manyTypes.FindProperty("PhysicalAddressToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(physicalAddressToStringConverterPropertyColumn, manyTypes.FindProperty("PhysicalAddressToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringColumn, manyTypes.FindProperty("String")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringArrayColumn, manyTypes.FindProperty("StringArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToBoolConverterPropertyColumn, manyTypes.FindProperty("StringToBoolConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToBytesConverterPropertyColumn, manyTypes.FindProperty("StringToBytesConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToCharConverterPropertyColumn, manyTypes.FindProperty("StringToCharConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToDateOnlyConverterPropertyColumn, manyTypes.FindProperty("StringToDateOnlyConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToDateTimeConverterPropertyColumn, manyTypes.FindProperty("StringToDateTimeConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToDateTimeOffsetConverterPropertyColumn, manyTypes.FindProperty("StringToDateTimeOffsetConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToDecimalNumberConverterPropertyColumn, manyTypes.FindProperty("StringToDecimalNumberConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToDoubleNumberConverterPropertyColumn, manyTypes.FindProperty("StringToDoubleNumberConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToEnumConverterPropertyColumn, manyTypes.FindProperty("StringToEnumConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToGuidConverterPropertyColumn, manyTypes.FindProperty("StringToGuidConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToIntNumberConverterPropertyColumn, manyTypes.FindProperty("StringToIntNumberConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToTimeOnlyConverterPropertyColumn, manyTypes.FindProperty("StringToTimeOnlyConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToTimeSpanConverterPropertyColumn, manyTypes.FindProperty("StringToTimeSpanConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(stringToUriConverterPropertyColumn, manyTypes.FindProperty("StringToUriConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyColumn, manyTypes.FindProperty("TimeOnly")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyArrayColumn, manyTypes.FindProperty("TimeOnlyArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyToStringConverterPropertyColumn, manyTypes.FindProperty("TimeOnlyToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeOnlyToTicksConverterPropertyColumn, manyTypes.FindProperty("TimeOnlyToTicksConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanColumn, manyTypes.FindProperty("TimeSpan")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanArrayColumn, manyTypes.FindProperty("TimeSpanArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanToStringConverterPropertyColumn, manyTypes.FindProperty("TimeSpanToStringConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(timeSpanToTicksConverterPropertyColumn, manyTypes.FindProperty("TimeSpanToTicksConverterProperty")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16Column, manyTypes.FindProperty("UInt16")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt16ArrayColumn, manyTypes.FindProperty("UInt16Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32Column, manyTypes.FindProperty("UInt32")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt32ArrayColumn, manyTypes.FindProperty("UInt32Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64Column, manyTypes.FindProperty("UInt64")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt64ArrayColumn, manyTypes.FindProperty("UInt64Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8Column, manyTypes.FindProperty("UInt8")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uInt8ArrayColumn, manyTypes.FindProperty("UInt8Array")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);
            RelationalModel.CreateColumnMapping(uriToStringConverterPropertyColumn, manyTypes.FindProperty("UriToStringConverterProperty")!, manyTypesTableMapping);

            var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase")!;

            var defaultTableMappings3 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBase.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings3);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", null, relationalModel);
            var alternateIdColumnBase = new ColumnBase<ColumnMappingBase>("AlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("AlternateId", alternateIdColumnBase);
            var enum1ColumnBase = new ColumnBase<ColumnMappingBase>("Enum1", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum1", enum1ColumnBase);
            var enum2ColumnBase = new ColumnBase<ColumnMappingBase>("Enum2", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Enum2", enum2ColumnBase);
            var flagsEnum1ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum1", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum1", flagsEnum1ColumnBase);
            var flagsEnum2ColumnBase = new ColumnBase<ColumnMappingBase>("FlagsEnum2", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("FlagsEnum2", flagsEnum2ColumnBase);
            var idColumnBase2 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Id", idColumnBase2);
            var pointColumnBase0 = new ColumnBase<ColumnMappingBase>("Point", "geometry", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("Point", pointColumnBase0);
            var refTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase);
            var refTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase);
            var refTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase);
            var refTypeListColumnBase = new ColumnBase<ColumnMappingBase>("RefTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("RefTypeList", refTypeListColumnBase);
            var valueTypeArrayColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase);
            var valueTypeEnumerableColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase);
            var valueTypeIListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase);
            var valueTypeListColumnBase = new ColumnBase<ColumnMappingBase>("ValueTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase = new TableMappingBase<ColumnMappingBase>(principalBase, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase, false);
            defaultTableMappings3.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalBase.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase2, principalBase.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalBase.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalBase.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalBase.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalBase.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase0, principalBase.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalBase.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalBase.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalBase.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalBase.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalBase.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalBase.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalBase.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalBase.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase);

            var tableMappings3 = new List<TableMapping>();
            principalBase.SetRuntimeAnnotation("Relational:TableMappings", tableMappings3);
            var principalBaseTable = new Table("PrincipalBase", "mySchema", relationalModel);
            var idColumn2 = new Column("Id", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("Id", idColumn2);
            var alternateIdColumn = new Column("AlternateId", "TEXT", principalBaseTable);
            principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
            var enum1Column = new Column("Enum1", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("Enum1", enum1Column);
            var enum2Column = new Column("Enum2", "INTEGER", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Enum2", enum2Column);
            var flagsEnum1Column = new Column("FlagsEnum1", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
            var flagsEnum2Column = new Column("FlagsEnum2", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
            var owned_NumberColumn = new Column("Owned_Number", "INTEGER", principalBaseTable);
            principalBaseTable.Columns.Add("Owned_Number", owned_NumberColumn);
            var owned_RefTypeArrayColumn = new Column("Owned_RefTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeArray", owned_RefTypeArrayColumn);
            var owned_RefTypeEnumerableColumn = new Column("Owned_RefTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeEnumerable", owned_RefTypeEnumerableColumn);
            var owned_RefTypeIListColumn = new Column("Owned_RefTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeIList", owned_RefTypeIListColumn);
            var owned_RefTypeListColumn = new Column("Owned_RefTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_RefTypeList", owned_RefTypeListColumn);
            var owned_ValueTypeArrayColumn = new Column("Owned_ValueTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeArray", owned_ValueTypeArrayColumn);
            var owned_ValueTypeEnumerableColumn = new Column("Owned_ValueTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeEnumerable", owned_ValueTypeEnumerableColumn);
            var owned_ValueTypeIListColumn = new Column("Owned_ValueTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeIList", owned_ValueTypeIListColumn);
            var owned_ValueTypeListColumn = new Column("Owned_ValueTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Owned_ValueTypeList", owned_ValueTypeListColumn);
            var pointColumn0 = new Column("Point", "geometry", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("Point", pointColumn0);
            var refTypeArrayColumn = new Column("RefTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
            var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
            var refTypeIListColumn = new Column("RefTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
            var refTypeListColumn = new Column("RefTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
            var valueTypeArrayColumn = new Column("ValueTypeArray", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
            var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
            var valueTypeIListColumn = new Column("ValueTypeIList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
            var valueTypeListColumn = new Column("ValueTypeList", "TEXT", principalBaseTable)
            {
                IsNullable = true
            };
            principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn2 });
            var aK_PrincipalBase_IdUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdUc);
            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdUc).Add(aK_PrincipalBase_Id);
            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn2, alternateIdColumn });
            principalBaseTable.PrimaryKey = pK;
            var pKUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            pK.MappedKeys.Add(pKUc);
            RelationalModel.GetOrCreateUniqueConstraints(pKUc).Add(pK);
            var pKUc0 = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            pK.MappedKeys.Add(pKUc0);
            RelationalModel.GetOrCreateUniqueConstraints(pKUc0).Add(pK);
            principalBaseTable.UniqueConstraints.Add("PK", pK);
            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn2 }, false);
            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "AlternateId", "Id" });
            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
            relationalModel.Tables.Add(("PrincipalBase", "mySchema"), principalBaseTable);
            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
            {
                IsSharedTablePrincipal = true,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
            tableMappings3.Add(principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalBase.FindProperty("AlternateId")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(idColumn2, principalBase.FindProperty("Id")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(pointColumn0, principalBase.FindProperty("Point")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);

            var ownedType = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType")!;

            var defaultTableMappings4 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings4);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", null, relationalModel);
            var detailsColumnBase = new ColumnBase<ColumnMappingBase>("Details", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("Details", detailsColumnBase);
            var numberColumnBase = new ColumnBase<ColumnMappingBase>("Number", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("Number", numberColumnBase);
            var principalBaseAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseAlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumnBase);
            var principalBaseIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalBaseId", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("PrincipalBaseId", principalBaseIdColumnBase);
            var refTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase0);
            var refTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase0);
            var refTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase0);
            var refTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("RefTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("RefTypeList", refTypeListColumnBase0);
            var valueTypeArrayColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase0);
            var valueTypeEnumerableColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase0);
            var valueTypeIListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase0);
            var valueTypeListColumnBase0 = new ColumnBase<ColumnMappingBase>("ValueTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase0);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase, false);
            defaultTableMappings4.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseAlternateIdColumnBase, ownedType.FindProperty("PrincipalBaseAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalBaseIdColumnBase, ownedType.FindProperty("PrincipalBaseId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)detailsColumnBase, ownedType.FindProperty("Details")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)numberColumnBase, ownedType.FindProperty("Number")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase0, ownedType.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase0, ownedType.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase0, ownedType.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase0, ownedType.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase0, ownedType.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase0, ownedType.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase0, ownedType.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase0, ownedType.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseOwnedOwnedTypeMappingBase);

            var tableMappings4 = new List<TableMapping>();
            ownedType.SetRuntimeAnnotation("Relational:TableMappings", tableMappings4);
            var principalBaseTableMapping0 = new TableMapping(ownedType, principalBaseTable, true)
            {
                IsSharedTablePrincipal = false,
                IsSplitEntityTypePrincipal = true
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping0, false);
            tableMappings4.Add(principalBaseTableMapping0);
            principalBaseTable.AddRowInternalForeignKey(ownedType, RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" }));
            RelationalModel.CreateColumnMapping(alternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(idColumn2, ownedType.FindProperty("PrincipalBaseId")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_NumberColumn, ownedType.FindProperty("Number")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeArrayColumn, ownedType.FindProperty("RefTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeEnumerableColumn, ownedType.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeIListColumn, ownedType.FindProperty("RefTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_RefTypeListColumn, ownedType.FindProperty("RefTypeList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeArrayColumn, ownedType.FindProperty("ValueTypeArray")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeEnumerableColumn, ownedType.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeIListColumn, ownedType.FindProperty("ValueTypeIList")!, principalBaseTableMapping0);
            RelationalModel.CreateColumnMapping(owned_ValueTypeListColumn, ownedType.FindProperty("ValueTypeList")!, principalBaseTableMapping0);
            var detailsTable = new Table("Details", null, relationalModel);
            var principalBaseIdColumn = new Column("PrincipalBaseId", "INTEGER", detailsTable);
            detailsTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
            var principalBaseAlternateIdColumn = new Column("PrincipalBaseAlternateId", "TEXT", detailsTable);
            detailsTable.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumn);
            var detailsColumn = new Column("Details", "TEXT", detailsTable)
            {
                IsNullable = true
            };
            detailsTable.Columns.Add("Details", detailsColumn);
            var pK_Details = new UniqueConstraint("PK_Details", detailsTable, new[] { principalBaseIdColumn, principalBaseAlternateIdColumn });
            detailsTable.PrimaryKey = pK_Details;
            var pK_DetailsUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            pK_Details.MappedKeys.Add(pK_DetailsUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_DetailsUc).Add(pK_Details);
            detailsTable.UniqueConstraints.Add("PK_Details", pK_Details);
            relationalModel.Tables.Add(("Details", null), detailsTable);
            var detailsTableMapping = new TableMapping(ownedType, detailsTable, true)
            {
                IsSplitEntityTypePrincipal = false
            };
            detailsTable.AddTypeMapping(detailsTableMapping, false);
            tableMappings4.Add(detailsTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseAlternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, detailsTableMapping);
            RelationalModel.CreateColumnMapping(principalBaseIdColumn, ownedType.FindProperty("PrincipalBaseId")!, detailsTableMapping);
            RelationalModel.CreateColumnMapping(detailsColumn, ownedType.FindProperty("Details")!, detailsTableMapping);

            var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>")!;

            var defaultTableMappings5 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings5);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0 = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase, false);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0, false);
            defaultTableMappings5.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase, principalDerived.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase2, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum1ColumnBase, principalDerived.FindProperty("Enum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)enum2ColumnBase, principalDerived.FindProperty("Enum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum1ColumnBase, principalDerived.FindProperty("FlagsEnum1")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)flagsEnum2ColumnBase, principalDerived.FindProperty("FlagsEnum2")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)pointColumnBase0, principalDerived.FindProperty("Point")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase, principalDerived.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase, principalDerived.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase, principalDerived.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase, principalDerived.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase, principalDerived.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase, principalDerived.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase, principalDerived.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase, principalDerived.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalBaseMappingBase0);

            var defaultTableMappings6 = new List<TableMappingBase<ColumnMappingBase>>();
            principalDerived.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings6);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", null, relationalModel);
            var alternateIdColumnBase0 = new ColumnBase<ColumnMappingBase>("AlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("AlternateId", alternateIdColumnBase0);
            var idColumnBase3 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.Columns.Add("Id", idColumnBase3);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalDerived, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase, false);
            defaultTableMappings6.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)alternateIdColumnBase0, principalDerived.FindProperty("AlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase3, principalDerived.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteMappingBase);

            var tableMappings5 = new List<TableMapping>();
            principalDerived.SetRuntimeAnnotation("Relational:TableMappings", tableMappings5);
            var principalBaseTableMapping1 = new TableMapping(principalDerived, principalBaseTable, false)
            {
                IsSharedTablePrincipal = false,
            };
            principalBaseTable.AddTypeMapping(principalBaseTableMapping1, false);
            tableMappings5.Add(principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(alternateIdColumn, principalDerived.FindProperty("AlternateId")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(idColumn2, principalDerived.FindProperty("Id")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum1Column, principalDerived.FindProperty("Enum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(enum2Column, principalDerived.FindProperty("Enum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalDerived.FindProperty("FlagsEnum1")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalDerived.FindProperty("FlagsEnum2")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(pointColumn0, principalDerived.FindProperty("Point")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalDerived.FindProperty("RefTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalDerived.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalDerived.FindProperty("RefTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(refTypeListColumn, principalDerived.FindProperty("RefTypeList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalDerived.FindProperty("ValueTypeArray")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping1);
            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping1);
            var principalDerivedTable = new Table("PrincipalDerived", null, relationalModel);
            var derivedIdColumn = new Column("DerivedId", "INTEGER", principalDerivedTable);
            principalDerivedTable.Columns.Add("DerivedId", derivedIdColumn);
            var alternateIdColumn0 = new Column("AlternateId", "TEXT", principalDerivedTable);
            principalDerivedTable.Columns.Add("AlternateId", alternateIdColumn0);
            var aK_PrincipalDerived_DerivedId = new UniqueConstraint("AK_PrincipalDerived_DerivedId", principalDerivedTable, new[] { derivedIdColumn });
            var aK_PrincipalDerived_DerivedIdUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            aK_PrincipalDerived_DerivedId.MappedKeys.Add(aK_PrincipalDerived_DerivedIdUc);
            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalDerived_DerivedIdUc).Add(aK_PrincipalDerived_DerivedId);
            principalDerivedTable.UniqueConstraints.Add("AK_PrincipalDerived_DerivedId", aK_PrincipalDerived_DerivedId);
            var pK0 = new UniqueConstraint("PK", principalDerivedTable, new[] { derivedIdColumn, alternateIdColumn0 });
            principalDerivedTable.PrimaryKey = pK0;
            var pK0Uc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            pK0.MappedKeys.Add(pK0Uc);
            RelationalModel.GetOrCreateUniqueConstraints(pK0Uc).Add(pK0);
            principalDerivedTable.UniqueConstraints.Add("PK", pK0);
            var iX_PrincipalDerived_AlternateId_DerivedId = new TableIndex(
            "IX_PrincipalDerived_AlternateId_DerivedId", principalDerivedTable, new[] { alternateIdColumn0, derivedIdColumn }, false);
            var iX_PrincipalDerived_AlternateId_DerivedIdIx = RelationalModel.GetIndex(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "AlternateId", "Id" });
            iX_PrincipalDerived_AlternateId_DerivedId.MappedIndexes.Add(iX_PrincipalDerived_AlternateId_DerivedIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalDerived_AlternateId_DerivedIdIx).Add(iX_PrincipalDerived_AlternateId_DerivedId);
            principalDerivedTable.Indexes.Add("IX_PrincipalDerived_AlternateId_DerivedId", iX_PrincipalDerived_AlternateId_DerivedId);
            relationalModel.Tables.Add(("PrincipalDerived", null), principalDerivedTable);
            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, true);
            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
            tableMappings5.Add(principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(alternateIdColumn0, principalDerived.FindProperty("AlternateId")!, principalDerivedTableMapping);
            RelationalModel.CreateColumnMapping(derivedIdColumn, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);

            var ownedType0 = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType")!;

            var defaultTableMappings7 = new List<TableMappingBase<ColumnMappingBase>>();
            ownedType0.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings7);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase = new TableBase("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", null, relationalModel);
            var detailsColumnBase0 = new ColumnBase<ColumnMappingBase>("Details", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Details", detailsColumnBase0);
            var idColumnBase4 = new ColumnBase<ColumnMappingBase>("Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Id", idColumnBase4);
            var numberColumnBase0 = new ColumnBase<ColumnMappingBase>("Number", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("Number", numberColumnBase0);
            var principalDerivedDependentBasebyteAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>AlternateId", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumnBase);
            var principalDerivedDependentBasebyteIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalDerived<DependentBase<byte?>>Id", "INTEGER", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumnBase);
            var refTypeArrayColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeArray", refTypeArrayColumnBase1);
            var refTypeEnumerableColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumnBase1);
            var refTypeIListColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeIList", refTypeIListColumnBase1);
            var refTypeListColumnBase1 = new ColumnBase<ColumnMappingBase>("RefTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("RefTypeList", refTypeListColumnBase1);
            var valueTypeArrayColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeArray", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeArray", valueTypeArrayColumnBase1);
            var valueTypeEnumerableColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeEnumerable", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumnBase1);
            var valueTypeIListColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeIList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeIList", valueTypeIListColumnBase1);
            var valueTypeListColumnBase1 = new ColumnBase<ColumnMappingBase>("ValueTypeList", "TEXT", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase)
            {
                IsNullable = true
            };
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.Columns.Add("ValueTypeList", valueTypeListColumnBase1);
            relationalModel.DefaultTables.Add("Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType", microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase);
            var microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase = new TableMappingBase<ColumnMappingBase>(ownedType0, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase, true);
            microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeTableBase.AddTypeMapping(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase, false);
            defaultTableMappings7.Add(microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)idColumnBase4, ownedType0.FindProperty("Id")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteAlternateIdColumnBase, ownedType0.FindProperty("PrincipalDerivedAlternateId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalDerivedDependentBasebyteIdColumnBase, ownedType0.FindProperty("PrincipalDerivedId")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)detailsColumnBase0, ownedType0.FindProperty("Details")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)numberColumnBase0, ownedType0.FindProperty("Number")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeArrayColumnBase1, ownedType0.FindProperty("RefTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeEnumerableColumnBase1, ownedType0.FindProperty("RefTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeIListColumnBase1, ownedType0.FindProperty("RefTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)refTypeListColumnBase1, ownedType0.FindProperty("RefTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeArrayColumnBase1, ownedType0.FindProperty("ValueTypeArray")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeEnumerableColumnBase1, ownedType0.FindProperty("ValueTypeEnumerable")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeIListColumnBase1, ownedType0.FindProperty("ValueTypeIList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)valueTypeListColumnBase1, ownedType0.FindProperty("ValueTypeList")!, microsoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestPrincipalDerivedMicrosoftEntityFrameworkCoreScaffoldingInternalCSharpRuntimeModelCodeGeneratorTestDependentBasebyteManyOwnedOwnedTypeMappingBase);

            var tableMappings6 = new List<TableMapping>();
            ownedType0.SetRuntimeAnnotation("Relational:TableMappings", tableMappings6);
            var manyOwnedTable = new Table("ManyOwned", null, relationalModel);
            var principalDerivedDependentBasebyteIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>Id", "INTEGER", manyOwnedTable);
            manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn);
            var principalDerivedDependentBasebyteAlternateIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>AlternateId", "TEXT", manyOwnedTable);
            manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumn);
            var idColumn3 = new Column("Id", "INTEGER", manyOwnedTable);
            manyOwnedTable.Columns.Add("Id", idColumn3);
            var detailsColumn0 = new Column("Details", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("Details", detailsColumn0);
            var numberColumn = new Column("Number", "INTEGER", manyOwnedTable);
            manyOwnedTable.Columns.Add("Number", numberColumn);
            var refTypeArrayColumn0 = new Column("RefTypeArray", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeArray", refTypeArrayColumn0);
            var refTypeEnumerableColumn0 = new Column("RefTypeEnumerable", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn0);
            var refTypeIListColumn0 = new Column("RefTypeIList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeIList", refTypeIListColumn0);
            var refTypeListColumn0 = new Column("RefTypeList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("RefTypeList", refTypeListColumn0);
            var valueTypeArrayColumn0 = new Column("ValueTypeArray", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn0);
            var valueTypeEnumerableColumn0 = new Column("ValueTypeEnumerable", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn0);
            var valueTypeIListColumn0 = new Column("ValueTypeIList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeIList", valueTypeIListColumn0);
            var valueTypeListColumn0 = new Column("ValueTypeList", "TEXT", manyOwnedTable)
            {
                IsNullable = true
            };
            manyOwnedTable.Columns.Add("ValueTypeList", valueTypeListColumn0);
            var pK_ManyOwned = new UniqueConstraint("PK_ManyOwned", manyOwnedTable, new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn, idColumn3 });
            manyOwnedTable.PrimaryKey = pK_ManyOwned;
            var pK_ManyOwnedUc = RelationalModel.GetKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId", "Id" });
            pK_ManyOwned.MappedKeys.Add(pK_ManyOwnedUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyOwnedUc).Add(pK_ManyOwned);
            manyOwnedTable.UniqueConstraints.Add("PK_ManyOwned", pK_ManyOwned);
            relationalModel.Tables.Add(("ManyOwned", null), manyOwnedTable);
            var manyOwnedTableMapping = new TableMapping(ownedType0, manyOwnedTable, true);
            manyOwnedTable.AddTypeMapping(manyOwnedTableMapping, false);
            tableMappings6.Add(manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(idColumn3, ownedType0.FindProperty("Id")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteAlternateIdColumn, ownedType0.FindProperty("PrincipalDerivedAlternateId")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteIdColumn, ownedType0.FindProperty("PrincipalDerivedId")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(detailsColumn0, ownedType0.FindProperty("Details")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(numberColumn, ownedType0.FindProperty("Number")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeArrayColumn0, ownedType0.FindProperty("RefTypeArray")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn0, ownedType0.FindProperty("RefTypeEnumerable")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeIListColumn0, ownedType0.FindProperty("RefTypeIList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(refTypeListColumn0, ownedType0.FindProperty("RefTypeList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeArrayColumn0, ownedType0.FindProperty("ValueTypeArray")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn0, ownedType0.FindProperty("ValueTypeEnumerable")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeIListColumn0, ownedType0.FindProperty("ValueTypeIList")!, manyOwnedTableMapping);
            RelationalModel.CreateColumnMapping(valueTypeListColumn0, ownedType0.FindProperty("ValueTypeList")!, manyOwnedTableMapping);

            var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;

            var defaultTableMappings8 = new List<TableMappingBase<ColumnMappingBase>>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:DefaultMappings", defaultTableMappings8);
            var principalBasePrincipalDerivedDependentBasebyteTableBase = new TableBase("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumnBase);
            var derivedsIdColumnBase = new ColumnBase<ColumnMappingBase>("DerivedsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("DerivedsId", derivedsIdColumnBase);
            var principalsAlternateIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumnBase);
            var principalsIdColumnBase = new ColumnBase<ColumnMappingBase>("PrincipalsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTableBase);
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("PrincipalsId", principalsIdColumnBase);
            var rowidColumnBase = new ColumnBase<ColumnMappingBase>("rowid", "BLOB", principalBasePrincipalDerivedDependentBasebyteTableBase)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTableBase.Columns.Add("rowid", rowidColumnBase);
            relationalModel.DefaultTables.Add("PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTableBase);
            var principalBasePrincipalDerivedDependentBasebyteMappingBase = new TableMappingBase<ColumnMappingBase>(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTableBase, true);
            principalBasePrincipalDerivedDependentBasebyteTableBase.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteMappingBase, false);
            defaultTableMappings8.Add(principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)derivedsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsAlternateIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)principalsIdColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);
            RelationalModel.CreateColumnMapping((ColumnBase<ColumnMappingBase>)rowidColumnBase, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteMappingBase);

            var tableMappings7 = new List<TableMapping>();
            principalBasePrincipalDerivedDependentBasebyte.SetRuntimeAnnotation("Relational:TableMappings", tableMappings7);
            var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
            var derivedsIdColumn = new Column("DerivedsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
            var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
            var principalsIdColumn = new Column("PrincipalsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
            var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
            var rowidColumn = new Column("rowid", "BLOB", principalBasePrincipalDerivedDependentBasebyteTable)
            {
                IsNullable = true
            };
            principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
            var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
            principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
            var pK_PrincipalBasePrincipalDerivedDependentBasebyteUc = RelationalModel.GetKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
            pK_PrincipalBasePrincipalDerivedDependentBasebyte.MappedKeys.Add(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc);
            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBasePrincipalDerivedDependentBasebyteUc).Add(pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
            "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
            var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" });
            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, true);
            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
            tableMappings7.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
            var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                new[] { principalIdColumn },
                principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
            var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id" });
            fK_DependentBasebyte_PrincipalBase_PrincipalId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalBase_PrincipalIdFk).Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalBase_PrincipalId);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId = new ForeignKeyConstraint(
                "FK_DependentBase<byte?>_PrincipalDerived_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalDerivedTable,
                new[] { principalIdColumn, principalAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
            var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                new[] { "PrincipalId", "PrincipalAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId.MappedForeignKeys.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk).Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            dependentBasebyteTable.ForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId);
            var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId = new ForeignKeyConstraint(
                "FK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId", detailsTable, principalBaseTable,
                new[] { principalBaseIdColumn, principalBaseAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
            fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId.MappedForeignKeys.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk).Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            detailsTable.ForeignKeyConstraints.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId);
            var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId = new ForeignKeyConstraint(
                "FK_ManyOwned_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id_PrincipalDerived<DependentBase<byte?>>AlternateId", manyOwnedTable, principalDerivedTable,
                new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId.MappedForeignKeys.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk).Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            manyOwnedTable.ForeignKeyConstraints.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                new[] { principalsIdColumn, principalsAlternateIdColumn },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "PrincipalsId", "PrincipalsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId = new ForeignKeyConstraint(
                "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalDerived_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalDerivedTable,
                new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                new[] { "DerivedsId", "DerivedsAlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" });
            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId.MappedForeignKeys.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk).Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            principalBasePrincipalDerivedDependentBasebyteTable.ForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            principalDerivedTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId);
            var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId = new ForeignKeyConstraint(
                "FK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId", principalDerivedTable, principalBaseTable,
                new[] { derivedIdColumn, alternateIdColumn0 },
                principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
            var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk = RelationalModel.GetForeignKey(this,
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                new[] { "Id", "AlternateId" },
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                new[] { "Id", "AlternateId" });
            fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId.MappedForeignKeys.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk);
            RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk).Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            principalDerivedTable.ForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            principalBaseTable.ReferencingForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId);
            return relationalModel.MakeReadOnly();
        }
    }
}
""", c),
                    c => AssertFileContents(
                        "DataEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class DataEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+Data",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Data),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var blob = runtimeEntityType.AddProperty(
                "Blob",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetProperty("Blob", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.Data).GetField("<Blob>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            blob.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var point = runtimeEntityType.AddProperty(
                "Point",
                typeof(Point),
                nullable: true);
            point.TypeMapping = null;

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Data");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.ValueGeneration;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class DependentBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.One);

            var principalId = runtimeEntityType.AddProperty(
                "PrincipalId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var principalAlternateId = runtimeEntityType.AddProperty(
                "PrincipalAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var enumDiscriminator = runtimeEntityType.AddProperty(
                "EnumDiscriminator",
                typeof(CSharpMigrationsGeneratorTest.Enum1),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
            enumDiscriminator.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                keyComparer: new ValueComparer<CSharpMigrationsGeneratorTest.Enum1>(
                    (CSharpMigrationsGeneratorTest.Enum1 v1, CSharpMigrationsGeneratorTest.Enum1 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v.GetHashCode(),
                    (CSharpMigrationsGeneratorTest.Enum1 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                    (int value) => (CSharpMigrationsGeneratorTest.Enum1)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpMigrationsGeneratorTest.Enum1, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpMigrationsGeneratorTest.Enum1, int>(
                        (CSharpMigrationsGeneratorTest.Enum1 value) => (int)value,
                        (int value) => (CSharpMigrationsGeneratorTest.Enum1)value)));
            enumDiscriminator.SetSentinelFromProviderValue(0);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Id", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            id.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var key = runtimeEntityType.AddKey(
                new[] { principalId, principalAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalId },
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalId"), declaringEntityType.FindProperty("PrincipalAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.ClientNoAction,
                unique: true,
                required: true);

            var principal = declaringEntityType.AddNavigation("Principal",
                runtimeForeignKey,
                onDependent: true,
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var dependent = principalEntityType.AddNavigation("Dependent",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Dependent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Dependent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("DiscriminatorMappingComplete", false);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPH");
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "ManyTypesEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Reflection;
using System.Text;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Json.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class ManyTypesEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+ManyTypes",
                typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypesId),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                valueConverter: new CSharpRuntimeModelCodeGeneratorTest.ManyTypesIdConverter());
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.ManyTypesId>(
                    (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v1, CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v2) => v1.Equals(v2),
                    (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.ManyTypesId>(
                    (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v1, CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v2) => v1.Equals(v2),
                    (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.ManyTypesId, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v) => v.Id,
                    (int v) => new CSharpRuntimeModelCodeGeneratorTest.ManyTypesId(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.ManyTypesId, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.ManyTypesId, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.ManyTypesId v) => v.Id,
                        (int v) => new CSharpRuntimeModelCodeGeneratorTest.ManyTypesId(v))));
            id.SetSentinelFromProviderValue(0);

            var @bool = runtimeEntityType.AddProperty(
                "Bool",
                typeof(bool),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            @bool.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var boolArray = runtimeEntityType.AddProperty(
                "BoolArray",
                typeof(bool[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            boolArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                keyComparer: new ListComparer<bool>(new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<bool[], bool[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: BoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                "BoolToStringConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BoolToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BoolToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 1),
                converter: new ValueConverter<bool, string>(
                    (bool v) => (string)(v ? "B" : "A"),
                    (string v) => !string.IsNullOrEmpty(v) && (int)v.ToUpperInvariant()[0] == (int)'B'),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<bool, string>(
                        (bool v) => (string)(v ? "B" : "A"),
                        (string v) => !string.IsNullOrEmpty(v) && (int)v.ToUpperInvariant()[0] == (int)'B')));
            boolToStringConverterProperty.SetSentinelFromProviderValue("A");

            var boolToTwoValuesConverterProperty = runtimeEntityType.AddProperty(
                "BoolToTwoValuesConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BoolToTwoValuesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BoolToTwoValuesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            boolToTwoValuesConverterProperty.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<bool, byte>(
                    (bool v) => (byte)(v ? 1 : 0),
                    (byte v) => v == 1),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<bool, byte>(
                        (bool v) => (byte)(v ? 1 : 0),
                        (byte v) => v == 1)));
            boolToTwoValuesConverterProperty.SetSentinelFromProviderValue((byte)0);

            var boolToZeroOneConverterProperty = runtimeEntityType.AddProperty(
                "BoolToZeroOneConverterProperty",
                typeof(bool),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BoolToZeroOneConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BoolToZeroOneConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new BoolToZeroOneConverter<short>());
            boolToZeroOneConverterProperty.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<bool, short>(
                    (bool v) => (short)(v ? 1 : 0),
                    (short v) => v == 1),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<bool, short>(
                        (bool v) => (short)(v ? 1 : 0),
                        (short v) => v == 1)));
            boolToZeroOneConverterProperty.SetSentinelFromProviderValue((short)0);

            var bytes = runtimeEntityType.AddProperty(
                "Bytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Bytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Bytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytes.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var bytesArray = runtimeEntityType.AddProperty(
                "BytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            bytesArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance),
                elementMapping: SqliteByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray())));

            var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                "BytesToStringConverterProperty",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("BytesToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<BytesToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new BytesToStringConverter());
            bytesToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<byte[], string>(
                    (Byte[] v) => Convert.ToBase64String(v),
                    (string v) => Convert.FromBase64String(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<byte[], string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<byte[], string>(
                        (Byte[] v) => Convert.ToBase64String(v),
                        (string v) => Convert.FromBase64String(v))));

            var castingConverterProperty = runtimeEntityType.AddProperty(
                "CastingConverterProperty",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("CastingConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<CastingConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new CastingConverter<int, decimal>());
            castingConverterProperty.TypeMapping = SqliteDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                converter: new ValueConverter<int, decimal>(
                    (int v) => (decimal)v,
                    (decimal v) => (int)v),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, decimal>(
                    SqliteJsonDecimalReaderWriter.Instance,
                    new ValueConverter<int, decimal>(
                        (int v) => (decimal)v,
                        (decimal v) => (int)v)));
            castingConverterProperty.SetSentinelFromProviderValue(0m);

            var @char = runtimeEntityType.AddProperty(
                "Char",
                typeof(char),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Char", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Char>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: '\0');
            @char.TypeMapping = CharTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                keyComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                providerValueComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var charArray = runtimeEntityType.AddProperty(
                "CharArray",
                typeof(char[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            charArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                keyComparer: new ListComparer<char>(new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<char>(new JsonCollectionReaderWriter<char[], char[], char>(
                    JsonCharReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<char[], char[], char>(
                    JsonCharReaderWriter.Instance),
                elementMapping: CharTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var charToStringConverterProperty = runtimeEntityType.AddProperty(
                "CharToStringConverterProperty",
                typeof(char),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("CharToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<CharToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new CharToStringConverter());
            charToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                keyComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 1),
                converter: new ValueConverter<char, string>(
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => v.Length < 1 ? '\0' : v[0]),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<char, string>(
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => v.Length < 1 ? '\0' : v[0])));
            charToStringConverterProperty.SetSentinelFromProviderValue("\0");

            var dateOnly = runtimeEntityType.AddProperty(
                "DateOnly",
                typeof(DateOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateOnly(1, 1, 1));
            dateOnly.TypeMapping = SqliteDateOnlyTypeMapping.Default;

            var dateOnlyArray = runtimeEntityType.AddProperty(
                "DateOnlyArray",
                typeof(DateOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                keyComparer: new ListComparer<DateOnly>(new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateOnly>(new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateOnly[], DateOnly[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqliteDateOnlyTypeMapping.Default);

            var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateOnlyToStringConverterProperty",
                typeof(DateOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateOnlyToStringConverter());
            dateOnlyToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                keyComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 10),
                converter: new ValueConverter<DateOnly, string>(
                    (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
                    (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateOnly, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateOnly, string>(
                        (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
                        (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
            dateOnlyToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01");

            var dateTime = runtimeEntityType.AddProperty(
                "DateTime",
                typeof(DateTime),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTime.TypeMapping = SqliteDateTimeTypeMapping.Default;

            var dateTimeArray = runtimeEntityType.AddProperty(
                "DateTimeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dateTimeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToBinaryConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeOffsetToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeOffsetToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBinaryConverter());
            dateTimeOffsetToBinaryConverterProperty.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<DateTimeOffset, long>(
                    (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                    (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, long>(
                        (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
                        (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v))));
            dateTimeOffsetToBinaryConverterProperty.SetSentinelFromProviderValue(0L);

            var dateTimeOffsetToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToBytesConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeOffsetToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeOffsetToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToBytesConverter());
            dateTimeOffsetToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 12),
                converter: new ValueConverter<DateTimeOffset, byte[]>(
                    (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
                    (Byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, byte[]>(
                        (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
                        (Byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v))));
            dateTimeOffsetToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });

            var dateTimeOffsetToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeOffsetToStringConverterProperty",
                typeof(DateTimeOffset),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeOffsetToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeOffsetToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeOffsetToStringConverter());
            dateTimeOffsetToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                keyComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<DateTimeOffset, string>(
                    (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
                    (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateTimeOffset, string>(
                        (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
                        (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture))));
            dateTimeOffsetToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00+00:00");

            var dateTimeToBinaryConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToBinaryConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeToBinaryConverter());
            dateTimeToBinaryConverterProperty.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<DateTime, long>(
                    (DateTime v) => v.ToBinary(),
                    (long v) => DateTime.FromBinary(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<DateTime, long>(
                        (DateTime v) => v.ToBinary(),
                        (long v) => DateTime.FromBinary(v))));
            dateTimeToBinaryConverterProperty.SetSentinelFromProviderValue(0L);

            var dateTimeToStringConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToStringConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new DateTimeToStringConverter());
            dateTimeToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<DateTime, string>(
                    (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
                    (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<DateTime, string>(
                        (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
                        (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture))));
            dateTimeToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00");

            var dateTimeToTicksConverterProperty = runtimeEntityType.AddProperty(
                "DateTimeToTicksConverterProperty",
                typeof(DateTime),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DateTimeToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DateTimeToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            dateTimeToTicksConverterProperty.TypeMapping = SqliteDateTimeTypeMapping.Default;

            var @decimal = runtimeEntityType.AddProperty(
                "Decimal",
                typeof(decimal),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Decimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Decimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0m);
            @decimal.TypeMapping = SqliteDecimalTypeMapping.Default;

            var decimalArray = runtimeEntityType.AddProperty(
                "DecimalArray",
                typeof(decimal[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            decimalArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                keyComparer: new ListComparer<decimal>(new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<decimal>(new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<decimal[], decimal[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance),
                elementMapping: SqliteDecimalTypeMapping.Default);

            var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DecimalNumberToBytesConverterProperty",
                typeof(decimal),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DecimalNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DecimalNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<decimal>());
            decimalNumberToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 16),
                converter: new ValueConverter<decimal, byte[]>(
                    (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
                    (Byte[] v) => v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<decimal, byte[]>(
                        (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
                        (Byte[] v) => v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v))));
            decimalNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });

            var decimalNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "DecimalNumberToStringConverterProperty",
                typeof(decimal),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DecimalNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DecimalNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<decimal>());
            decimalNumberToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                keyComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<decimal, string>(
                    (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<decimal, string>(
                        (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            decimalNumberToStringConverterProperty.SetSentinelFromProviderValue("0");

            var @double = runtimeEntityType.AddProperty(
                "Double",
                typeof(double),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Double", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Double>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0.0);
            @double.TypeMapping = DoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var doubleArray = runtimeEntityType.AddProperty(
                "DoubleArray",
                typeof(double[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            doubleArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                keyComparer: new ListComparer<double>(new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<double>(new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<double[], double[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: DoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "DoubleNumberToBytesConverterProperty",
                typeof(double),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DoubleNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DoubleNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<double>());
            doubleNumberToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 8),
                converter: new ValueConverter<double, byte[]>(
                    (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
                    (Byte[] v) => v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<double, byte[]>(
                        (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
                        (Byte[] v) => v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0))));
            doubleNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });

            var doubleNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "DoubleNumberToStringConverterProperty",
                typeof(double),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("DoubleNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<DoubleNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<double>());
            doubleNumberToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                keyComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<double, string>(
                    (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v),
                    (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<double, string>(
                        (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v),
                        (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            doubleNumberToStringConverterProperty.SetSentinelFromProviderValue("0");

            var enum16 = runtimeEntityType.AddProperty(
                "Enum16",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum16.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                    (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)));
            enum16.SetSentinelFromProviderValue((short)0);

            var enum16Array = runtimeEntityType.AddProperty(
                "Enum16Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))));

            var enum16AsString = runtimeEntityType.AddProperty(
                "Enum16AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum16AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v))));
            enum16AsString.SetSentinelFromProviderValue("Default");

            var enum16AsStringArray = runtimeEntityType.AddProperty(
                "Enum16AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum16AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v)))));

            var enum16AsStringCollection = runtimeEntityType.AddProperty(
                "Enum16AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum16>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum16AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, string, CSharpRuntimeModelCodeGeneratorTest.Enum16>.ConvertToEnum(v)))));

            var enum16Collection = runtimeEntityType.AddProperty(
                "Enum16Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum16>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum16Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))));

            var enum32 = runtimeEntityType.AddProperty(
                "Enum32",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)));
            enum32.SetSentinelFromProviderValue(0);

            var enum32Array = runtimeEntityType.AddProperty(
                "Enum32Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))));

            var enum32AsString = runtimeEntityType.AddProperty(
                "Enum32AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum32AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v))));
            enum32AsString.SetSentinelFromProviderValue("Default");

            var enum32AsStringArray = runtimeEntityType.AddProperty(
                "Enum32AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum32AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)))));

            var enum32AsStringCollection = runtimeEntityType.AddProperty(
                "Enum32AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum32>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum32AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)))));

            var enum32Collection = runtimeEntityType.AddProperty(
                "Enum32Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum32>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum32Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))));

            var enum64 = runtimeEntityType.AddProperty(
                "Enum64",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum64.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                    (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)));
            enum64.SetSentinelFromProviderValue(0L);

            var enum64Array = runtimeEntityType.AddProperty(
                "Enum64Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))));

            var enum64AsString = runtimeEntityType.AddProperty(
                "Enum64AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum64AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v))));
            enum64AsString.SetSentinelFromProviderValue("Default");

            var enum64AsStringArray = runtimeEntityType.AddProperty(
                "Enum64AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum64AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v)))));

            var enum64AsStringCollection = runtimeEntityType.AddProperty(
                "Enum64AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum64>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum64AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, string, CSharpRuntimeModelCodeGeneratorTest.Enum64>.ConvertToEnum(v)))));

            var enum64Collection = runtimeEntityType.AddProperty(
                "Enum64Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum64>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum64Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))));

            var enum8 = runtimeEntityType.AddProperty(
                "Enum8",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum8.TypeMapping = SByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                providerValueComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                    (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                    JsonSByteReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)));
            enum8.SetSentinelFromProviderValue((sbyte)0);

            var enum8Array = runtimeEntityType.AddProperty(
                "Enum8Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))));

            var enum8AsString = runtimeEntityType.AddProperty(
                "Enum8AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enum8AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v))));
            enum8AsString.SetSentinelFromProviderValue("Default");

            var enum8AsStringArray = runtimeEntityType.AddProperty(
                "Enum8AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum8AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v)))));

            var enum8AsStringCollection = runtimeEntityType.AddProperty(
                "Enum8AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum8>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum8AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, string, CSharpRuntimeModelCodeGeneratorTest.Enum8>.ConvertToEnum(v)))));

            var enum8Collection = runtimeEntityType.AddProperty(
                "Enum8Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum8>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Enum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Enum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum8Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))));

            var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                "EnumToNumberConverterProperty",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumToNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumToNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new EnumToNumberConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>());
            enumToNumberConverterProperty.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)));
            enumToNumberConverterProperty.SetSentinelFromProviderValue(0);

            var enumToStringConverterProperty = runtimeEntityType.AddProperty(
                "EnumToStringConverterProperty",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new EnumToStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32>());
            enumToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, string, CSharpRuntimeModelCodeGeneratorTest.Enum32>.ConvertToEnum(v))));
            enumToStringConverterProperty.SetSentinelFromProviderValue("Default");

            var enumU16 = runtimeEntityType.AddProperty(
                "EnumU16",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU16.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                    (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                    JsonUInt16ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)));
            enumU16.SetSentinelFromProviderValue((ushort)0);

            var enumU16Array = runtimeEntityType.AddProperty(
                "EnumU16Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))));

            var enumU16AsString = runtimeEntityType.AddProperty(
                "EnumU16AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU16AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v))));
            enumU16AsString.SetSentinelFromProviderValue("Min");

            var enumU16AsStringArray = runtimeEntityType.AddProperty(
                "EnumU16AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU16AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v)))));

            var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU16AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU16AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, string, CSharpRuntimeModelCodeGeneratorTest.EnumU16>.ConvertToEnum(v)))));

            var enumU16Collection = runtimeEntityType.AddProperty(
                "EnumU16Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU16Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))));

            var enumU32 = runtimeEntityType.AddProperty(
                "EnumU32",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU32.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                    (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                    JsonUInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)));
            enumU32.SetSentinelFromProviderValue(0u);

            var enumU32Array = runtimeEntityType.AddProperty(
                "EnumU32Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))));

            var enumU32AsString = runtimeEntityType.AddProperty(
                "EnumU32AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU32AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v))));
            enumU32AsString.SetSentinelFromProviderValue("Min");

            var enumU32AsStringArray = runtimeEntityType.AddProperty(
                "EnumU32AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU32AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v)))));

            var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU32AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU32AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, string, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v)))));

            var enumU32Collection = runtimeEntityType.AddProperty(
                "EnumU32Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU32Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))));

            var enumU64 = runtimeEntityType.AddProperty(
                "EnumU64",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU64.TypeMapping = SqliteULongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                    (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                    JsonUInt64ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)));
            enumU64.SetSentinelFromProviderValue(0ul);

            var enumU64Array = runtimeEntityType.AddProperty(
                "EnumU64Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))),
                elementMapping: SqliteULongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))));

            var enumU64AsString = runtimeEntityType.AddProperty(
                "EnumU64AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU64AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v))));
            enumU64AsString.SetSentinelFromProviderValue("Min");

            var enumU64AsStringArray = runtimeEntityType.AddProperty(
                "EnumU64AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU64AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v)))));

            var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU64AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU64AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, string, CSharpRuntimeModelCodeGeneratorTest.EnumU64>.ConvertToEnum(v)))));

            var enumU64Collection = runtimeEntityType.AddProperty(
                "EnumU64Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU64Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))),
                elementMapping: SqliteULongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))));

            var enumU8 = runtimeEntityType.AddProperty(
                "EnumU8",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enumU8.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                    (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)));
            enumU8.SetSentinelFromProviderValue((byte)0);

            var enumU8Array = runtimeEntityType.AddProperty(
                "EnumU8Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))));

            var enumU8AsString = runtimeEntityType.AddProperty(
                "EnumU8AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                providerPropertyType: typeof(string));
            enumU8AsString.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                    (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v))));
            enumU8AsString.SetSentinelFromProviderValue("Min");

            var enumU8AsStringArray = runtimeEntityType.AddProperty(
                "EnumU8AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU8AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v)))));

            var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                "EnumU8AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU8AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                        (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.ToString(),
                            (string v) => StringEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, string, CSharpRuntimeModelCodeGeneratorTest.EnumU8>.ConvertToEnum(v)))));

            var enumU8Collection = runtimeEntityType.AddProperty(
                "EnumU8Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("EnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<EnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enumU8Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                keyComparer: new ListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))));

            var @float = runtimeEntityType.AddProperty(
                "Float",
                typeof(float),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Float", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Float>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0f);
            @float.TypeMapping = FloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                keyComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var floatArray = runtimeEntityType.AddProperty(
                "FloatArray",
                typeof(float[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            floatArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                keyComparer: new ListComparer<float>(new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<float>(new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<float[], float[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: FloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var guid = runtimeEntityType.AddProperty(
                "Guid",
                typeof(Guid),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Guid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Guid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            guid.TypeMapping = SqliteGuidTypeMapping.Default;

            var guidArray = runtimeEntityType.AddProperty(
                "GuidArray",
                typeof(Guid[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            guidArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                keyComparer: new ListComparer<Guid>(new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Guid[], Guid[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance),
                elementMapping: SqliteGuidTypeMapping.Default);

            var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                "GuidToBytesConverterProperty",
                typeof(Guid),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("GuidToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<GuidToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new GuidToBytesConverter());
            guidToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 16),
                converter: new ValueConverter<Guid, byte[]>(
                    (Guid v) => v.ToByteArray(),
                    (Byte[] v) => new Guid(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<Guid, byte[]>(
                        (Guid v) => v.ToByteArray(),
                        (Byte[] v) => new Guid(v))));
            guidToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });

            var guidToStringConverterProperty = runtimeEntityType.AddProperty(
                "GuidToStringConverterProperty",
                typeof(Guid),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("GuidToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<GuidToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new GuidToStringConverter());
            guidToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                keyComparer: new ValueComparer<Guid>(
                    (Guid v1, Guid v2) => v1 == v2,
                    (Guid v) => v.GetHashCode(),
                    (Guid v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 36),
                converter: new ValueConverter<Guid, string>(
                    (Guid v) => v.ToString("D"),
                    (string v) => new Guid(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Guid, string>(
                        (Guid v) => v.ToString("D"),
                        (string v) => new Guid(v))));
            guidToStringConverterProperty.SetSentinelFromProviderValue("00000000-0000-0000-0000-000000000000");

            var iPAddress = runtimeEntityType.AddProperty(
                "IPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 45),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));

            var iPAddressArray = runtimeEntityType.AddProperty(
                "IPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            iPAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                "IPAddressToBytesConverterProperty",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new IPAddressToBytesConverter());
            iPAddressToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 16),
                converter: new ValueConverter<IPAddress, byte[]>(
                    (IPAddress v) => v.GetAddressBytes(),
                    (Byte[] v) => new IPAddress(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<IPAddress, byte[]>(
                        (IPAddress v) => v.GetAddressBytes(),
                        (Byte[] v) => new IPAddress(v))));

            var iPAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                "IPAddressToStringConverterProperty",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IPAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IPAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new IPAddressToStringConverter());
            iPAddressToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 45),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));

            var int16 = runtimeEntityType.AddProperty(
                "Int16",
                typeof(short),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (short)0);
            int16.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                keyComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int16Array = runtimeEntityType.AddProperty(
                "Int16Array",
                typeof(short[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<short[], short[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var int32 = runtimeEntityType.AddProperty(
                "Int32",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            int32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int32Array = runtimeEntityType.AddProperty(
                "Int32Array",
                typeof(int[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                keyComparer: new ListComparer<int>(new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<int[], int[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var int64 = runtimeEntityType.AddProperty(
                "Int64",
                typeof(long),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0L);
            int64.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int64Array = runtimeEntityType.AddProperty(
                "Int64Array",
                typeof(long[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                keyComparer: new ListComparer<long>(new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<long>(new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<long[], long[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var int8 = runtimeEntityType.AddProperty(
                "Int8",
                typeof(sbyte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (sbyte)0);
            int8.TypeMapping = SByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                keyComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                providerValueComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var int8Array = runtimeEntityType.AddProperty(
                "Int8Array",
                typeof(sbyte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            int8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                keyComparer: new ListComparer<sbyte>(new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    JsonSByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<sbyte[], sbyte[], sbyte>(
                    JsonSByteReaderWriter.Instance),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                "IntNumberToBytesConverterProperty",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IntNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IntNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToBytesConverter<int>());
            intNumberToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 4),
                converter: new ValueConverter<int, byte[]>(
                    (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
                    (Byte[] v) => v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt(v.Length == 0 ? new byte[4] : v), 0)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<int, byte[]>(
                        (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
                        (Byte[] v) => v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt(v.Length == 0 ? new byte[4] : v), 0))));
            intNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0 });

            var intNumberToStringConverterProperty = runtimeEntityType.AddProperty(
                "IntNumberToStringConverterProperty",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("IntNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<IntNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new NumberToStringConverter<int>());
            intNumberToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<int, string>(
                    (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                    (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<int, string>(
                        (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v),
                        (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
            intNumberToStringConverterProperty.SetSentinelFromProviderValue("0");

            var nullIntToNullStringConverterProperty = runtimeEntityType.AddProperty(
                "NullIntToNullStringConverterProperty",
                typeof(int?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullIntToNullStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullIntToNullStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new CSharpRuntimeModelCodeGeneratorTest.NullIntToNullStringConverter());
            nullIntToNullStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1 == v2,
                    (Nullable<int> v) => (int)v,
                    (Nullable<int> v) => v),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1 == v2,
                    (Nullable<int> v) => (int)v,
                    (Nullable<int> v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<int?, string>(
                    (Nullable<int> v) => v == null ? null : v.ToString(),
                    (string v) => v == null || v == "<null>" ? null : (Nullable<int>)int.Parse(v),
                    convertsNulls: true),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int?, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<int?, string>(
                        (Nullable<int> v) => v == null ? null : v.ToString(),
                        (string v) => v == null || v == "<null>" ? null : (Nullable<int>)int.Parse(v),
                        convertsNulls: true)));

            var nullableBool = runtimeEntityType.AddProperty(
                "NullableBool",
                typeof(bool?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBool.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableBoolArray = runtimeEntityType.AddProperty(
                "NullableBoolArray",
                typeof(bool?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBoolArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                keyComparer: new NullableValueTypeListComparer<bool>(new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<bool?>(new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<bool?[], bool?[], bool>(
                    JsonBoolReaderWriter.Instance),
                elementMapping: BoolTypeMapping.Default.Clone(
                    comparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    keyComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    providerValueComparer: new ValueComparer<bool>(
                        (bool v1, bool v2) => v1 == v2,
                        (bool v) => v.GetHashCode(),
                        (bool v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableBytes = runtimeEntityType.AddProperty(
                "NullableBytes",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytes.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var nullableBytesArray = runtimeEntityType.AddProperty(
                "NullableBytesArray",
                typeof(byte[][]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableBytesArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                keyComparer: new ListComparer<byte[]>(new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<byte[][], byte[][], byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance),
                elementMapping: SqliteByteArrayTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => v.GetHashCode(),
                        (Byte[] v) => v),
                    keyComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray()),
                    providerValueComparer: new ValueComparer<byte[]>(
                        (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                        (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                        (Byte[] source) => source.ToArray())));

            var nullableChar = runtimeEntityType.AddProperty(
                "NullableChar",
                typeof(char?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableChar", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableChar>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableChar.TypeMapping = CharTypeMapping.Default.Clone(
                comparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                keyComparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                providerValueComparer: new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var nullableCharArray = runtimeEntityType.AddProperty(
                "NullableCharArray",
                typeof(char?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableCharArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                keyComparer: new NullableValueTypeListComparer<char>(new ValueComparer<char?>(
                    (Nullable<char> v1, Nullable<char> v2) => v1.HasValue && v2.HasValue && (char)v1 == (char)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<char> v) => v.HasValue ? (int)(char)v : 0,
                    (Nullable<char> v) => v.HasValue ? (Nullable<char>)(char)v : default(Nullable<char>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<char?>(new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    JsonCharReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<char?[], char?[], char>(
                    JsonCharReaderWriter.Instance),
                elementMapping: CharTypeMapping.Default.Clone(
                    comparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    keyComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    providerValueComparer: new ValueComparer<char>(
                        (char v1, char v2) => v1 == v2,
                        (char v) => (int)v,
                        (char v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var nullableDateOnly = runtimeEntityType.AddProperty(
                "NullableDateOnly",
                typeof(DateOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnly.TypeMapping = SqliteDateOnlyTypeMapping.Default;

            var nullableDateOnlyArray = runtimeEntityType.AddProperty(
                "NullableDateOnlyArray",
                typeof(DateOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                keyComparer: new NullableValueTypeListComparer<DateOnly>(new ValueComparer<DateOnly?>(
                    (Nullable<DateOnly> v1, Nullable<DateOnly> v2) => v1.HasValue && v2.HasValue && (DateOnly)v1 == (DateOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateOnly> v) => v.HasValue ? ((DateOnly)v).GetHashCode() : 0,
                    (Nullable<DateOnly> v) => v.HasValue ? (Nullable<DateOnly>)(DateOnly)v : default(Nullable<DateOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateOnly?>(new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateOnly?[], DateOnly?[], DateOnly>(
                    JsonDateOnlyReaderWriter.Instance),
                elementMapping: SqliteDateOnlyTypeMapping.Default);

            var nullableDateTime = runtimeEntityType.AddProperty(
                "NullableDateTime",
                typeof(DateTime?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTime.TypeMapping = SqliteDateTimeTypeMapping.Default;

            var nullableDateTimeArray = runtimeEntityType.AddProperty(
                "NullableDateTimeArray",
                typeof(DateTime?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDateTimeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                keyComparer: new NullableValueTypeListComparer<DateTime>(new ValueComparer<DateTime?>(
                    (Nullable<DateTime> v1, Nullable<DateTime> v2) => v1.HasValue && v2.HasValue && (DateTime)v1 == (DateTime)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTime> v) => v.HasValue ? ((DateTime)v).GetHashCode() : 0,
                    (Nullable<DateTime> v) => v.HasValue ? (Nullable<DateTime>)(DateTime)v : default(Nullable<DateTime>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime?>(new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<DateTime?[], DateTime?[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var nullableDecimal = runtimeEntityType.AddProperty(
                "NullableDecimal",
                typeof(decimal?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimal.TypeMapping = SqliteDecimalTypeMapping.Default;

            var nullableDecimalArray = runtimeEntityType.AddProperty(
                "NullableDecimalArray",
                typeof(decimal?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDecimalArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                keyComparer: new NullableValueTypeListComparer<decimal>(new ValueComparer<decimal?>(
                    (Nullable<decimal> v1, Nullable<decimal> v2) => v1.HasValue && v2.HasValue && (decimal)v1 == (decimal)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<decimal> v) => v.HasValue ? ((decimal)v).GetHashCode() : 0,
                    (Nullable<decimal> v) => v.HasValue ? (Nullable<decimal>)(decimal)v : default(Nullable<decimal>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<decimal?>(new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<decimal?[], decimal?[], decimal>(
                    SqliteJsonDecimalReaderWriter.Instance),
                elementMapping: SqliteDecimalTypeMapping.Default);

            var nullableDouble = runtimeEntityType.AddProperty(
                "NullableDouble",
                typeof(double?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDouble", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDouble>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDouble.TypeMapping = DoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var nullableDoubleArray = runtimeEntityType.AddProperty(
                "NullableDoubleArray",
                typeof(double?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableDoubleArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                keyComparer: new NullableValueTypeListComparer<double>(new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<double?>(new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<double?[], double?[], double>(
                    JsonDoubleReaderWriter.Instance),
                elementMapping: DoubleTypeMapping.Default.Clone(
                    comparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    keyComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    providerValueComparer: new ValueComparer<double>(
                        (double v1, double v2) => v1.Equals(v2),
                        (double v) => v.GetHashCode(),
                        (double v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var nullableEnum16 = runtimeEntityType.AddProperty(
                "NullableEnum16",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                    (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)));

            var nullableEnum16Array = runtimeEntityType.AddProperty(
                "NullableEnum16Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))));

            var nullableEnum16AsString = runtimeEntityType.AddProperty(
                "NullableEnum16AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16AsString.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)),
                providerValueComparer: new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                    (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                    JsonInt16ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)));

            var nullableEnum16AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum16AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum16?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16?[], CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))));

            var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum16AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))));

            var nullableEnum16Collection = runtimeEntityType.AddProperty(
                "NullableEnum16Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum16Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>)(CSharpRuntimeModelCodeGeneratorTest.Enum16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum16?>, CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum16>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v1, CSharpRuntimeModelCodeGeneratorTest.Enum16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                        (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                        JsonInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum16, short>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum16 value) => (short)value,
                            (short value) => (CSharpRuntimeModelCodeGeneratorTest.Enum16)value))));

            var nullableEnum32 = runtimeEntityType.AddProperty(
                "NullableEnum32",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)));

            var nullableEnum32Array = runtimeEntityType.AddProperty(
                "NullableEnum32Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))));

            var nullableEnum32AsString = runtimeEntityType.AddProperty(
                "NullableEnum32AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32AsString.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)));

            var nullableEnum32AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum32AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum32?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32?[], CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))));

            var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum32AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))));

            var nullableEnum32Collection = runtimeEntityType.AddProperty(
                "NullableEnum32Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum32Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>)(CSharpRuntimeModelCodeGeneratorTest.Enum32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum32?>, CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum32>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v1, CSharpRuntimeModelCodeGeneratorTest.Enum32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                        JsonInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum32, int>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum32 value) => (int)value,
                            (int value) => (CSharpRuntimeModelCodeGeneratorTest.Enum32)value))));

            var nullableEnum64 = runtimeEntityType.AddProperty(
                "NullableEnum64",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                    (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)));

            var nullableEnum64Array = runtimeEntityType.AddProperty(
                "NullableEnum64Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))));

            var nullableEnum64AsString = runtimeEntityType.AddProperty(
                "NullableEnum64AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64AsString.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                    (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)));

            var nullableEnum64AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum64AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum64?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64?[], CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))));

            var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum64AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))));

            var nullableEnum64Collection = runtimeEntityType.AddProperty(
                "NullableEnum64Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum64Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>)(CSharpRuntimeModelCodeGeneratorTest.Enum64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum64?>, CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum64>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v1, CSharpRuntimeModelCodeGeneratorTest.Enum64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                        (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                        JsonInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum64, long>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum64 value) => (long)value,
                            (long value) => (CSharpRuntimeModelCodeGeneratorTest.Enum64)value))));

            var nullableEnum8 = runtimeEntityType.AddProperty(
                "NullableEnum8",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8.TypeMapping = SByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)),
                providerValueComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                    (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                    JsonSByteReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)));

            var nullableEnum8Array = runtimeEntityType.AddProperty(
                "NullableEnum8Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))));

            var nullableEnum8AsString = runtimeEntityType.AddProperty(
                "NullableEnum8AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8AsString.TypeMapping = SByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)),
                providerValueComparer: new ValueComparer<sbyte>(
                    (sbyte v1, sbyte v2) => v1 == v2,
                    (sbyte v) => (int)v,
                    (sbyte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                    (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                    (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                    JsonSByteReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)));

            var nullableEnum8AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnum8AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.Enum8?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8?[], CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))));

            var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnum8AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))));

            var nullableEnum8Collection = runtimeEntityType.AddProperty(
                "NullableEnum8Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnum8Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.Enum8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>)(CSharpRuntimeModelCodeGeneratorTest.Enum8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.Enum8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, List<CSharpRuntimeModelCodeGeneratorTest.Enum8?>, CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.Enum8>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v1, CSharpRuntimeModelCodeGeneratorTest.Enum8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                        (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                        JsonSByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.Enum8, sbyte>(
                            (CSharpRuntimeModelCodeGeneratorTest.Enum8 value) => (sbyte)value,
                            (sbyte value) => (CSharpRuntimeModelCodeGeneratorTest.Enum8)value))));

            var nullableEnumU16 = runtimeEntityType.AddProperty(
                "NullableEnumU16",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)),
                providerValueComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                    (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                    JsonUInt16ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)));

            var nullableEnumU16Array = runtimeEntityType.AddProperty(
                "NullableEnumU16Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))));

            var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                "NullableEnumU16AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16AsString.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)),
                providerValueComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                    (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                    JsonUInt16ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)));

            var nullableEnumU16AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU16AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU16?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16?[], CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))));

            var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU16AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))));

            var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                "NullableEnumU16Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU16Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU16)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>)(CSharpRuntimeModelCodeGeneratorTest.EnumU16)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU16>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU16?>, CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU16>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU16 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                        (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                        JsonUInt16ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU16, ushort>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU16 value) => (ushort)value,
                            (ushort value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU16)value))));

            var nullableEnumU32 = runtimeEntityType.AddProperty(
                "NullableEnumU32",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                    (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                    JsonUInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)));

            var nullableEnumU32Array = runtimeEntityType.AddProperty(
                "NullableEnumU32Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))));

            var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                "NullableEnumU32AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32AsString.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                    (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                    JsonUInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)));

            var nullableEnumU32AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU32AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU32?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32?[], CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))));

            var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU32AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))));

            var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                "NullableEnumU32Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU32Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>)(CSharpRuntimeModelCodeGeneratorTest.EnumU32)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU32>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU32?>, CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU32>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU32 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                        (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                        JsonUInt32ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32, uint>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU32 value) => (uint)value,
                            (uint value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU32)value))));

            var nullableEnumU64 = runtimeEntityType.AddProperty(
                "NullableEnumU64",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64.TypeMapping = SqliteULongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)),
                providerValueComparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                    (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                    JsonUInt64ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)));

            var nullableEnumU64Array = runtimeEntityType.AddProperty(
                "NullableEnumU64Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))),
                elementMapping: SqliteULongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))));

            var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                "NullableEnumU64AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64AsString.TypeMapping = SqliteULongTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)),
                providerValueComparer: new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                    (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                    JsonUInt64ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)));

            var nullableEnumU64AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU64AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU64?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64?[], CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))),
                elementMapping: SqliteULongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))));

            var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU64AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))),
                elementMapping: SqliteULongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))));

            var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                "NullableEnumU64Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU64Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU64)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>)(CSharpRuntimeModelCodeGeneratorTest.EnumU64)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU64>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU64?>, CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))),
                elementMapping: SqliteULongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU64>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU64 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 v) => v),
                    providerValueComparer: new ValueComparer<ulong>(
                        (ulong v1, ulong v2) => v1 == v2,
                        (ulong v) => v.GetHashCode(),
                        (ulong v) => v),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                        (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                        JsonUInt64ReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU64, ulong>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU64 value) => (ulong)value,
                            (ulong value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU64)value))));

            var nullableEnumU8 = runtimeEntityType.AddProperty(
                "NullableEnumU8",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                    (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)));

            var nullableEnumU8Array = runtimeEntityType.AddProperty(
                "NullableEnumU8Array",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))));

            var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                "NullableEnumU8AsString",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8AsString.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                    (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                    (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)));

            var nullableEnumU8AsStringArray = runtimeEntityType.AddProperty(
                "NullableEnumU8AsStringArray",
                typeof(CSharpRuntimeModelCodeGeneratorTest.EnumU8?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8AsStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8?[], CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))));

            var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                "NullableEnumU8AsStringCollection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8AsStringCollection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))));

            var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                "NullableEnumU8Collection",
                typeof(List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableEnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableEnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableEnumU8Collection.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                keyComparer: new NullableValueTypeListComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.EnumU8)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>)(CSharpRuntimeModelCodeGeneratorTest.EnumU8)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.EnumU8>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>(new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value)))),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, List<CSharpRuntimeModelCodeGeneratorTest.EnumU8?>, CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                    new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.EnumU8>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v1, CSharpRuntimeModelCodeGeneratorTest.EnumU8 v2) => object.Equals((object)v1, (object)v2),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v.GetHashCode(),
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER"),
                    converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                        (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                        JsonByteReaderWriter.Instance,
                        new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU8, byte>(
                            (CSharpRuntimeModelCodeGeneratorTest.EnumU8 value) => (byte)value,
                            (byte value) => (CSharpRuntimeModelCodeGeneratorTest.EnumU8)value))));

            var nullableFloat = runtimeEntityType.AddProperty(
                "NullableFloat",
                typeof(float?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloat.TypeMapping = FloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL"));

            var nullableFloatArray = runtimeEntityType.AddProperty(
                "NullableFloatArray",
                typeof(float?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableFloatArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                keyComparer: new NullableValueTypeListComparer<float>(new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<float?>(new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<float?[], float?[], float>(
                    JsonFloatReaderWriter.Instance),
                elementMapping: FloatTypeMapping.Default.Clone(
                    comparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    keyComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    providerValueComparer: new ValueComparer<float>(
                        (float v1, float v2) => v1.Equals(v2),
                        (float v) => v.GetHashCode(),
                        (float v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "REAL")));

            var nullableGuid = runtimeEntityType.AddProperty(
                "NullableGuid",
                typeof(Guid?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuid.TypeMapping = SqliteGuidTypeMapping.Default;

            var nullableGuidArray = runtimeEntityType.AddProperty(
                "NullableGuidArray",
                typeof(Guid?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableGuidArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                keyComparer: new NullableValueTypeListComparer<Guid>(new ValueComparer<Guid?>(
                    (Nullable<Guid> v1, Nullable<Guid> v2) => v1.HasValue && v2.HasValue && (Guid)v1 == (Guid)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<Guid> v) => v.HasValue ? ((Guid)v).GetHashCode() : 0,
                    (Nullable<Guid> v) => v.HasValue ? (Nullable<Guid>)(Guid)v : default(Nullable<Guid>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Guid?>(new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<Guid?[], Guid?[], Guid>(
                    SqliteJsonGuidReaderWriter.Instance),
                elementMapping: SqliteGuidTypeMapping.Default);

            var nullableIPAddress = runtimeEntityType.AddProperty(
                "NullableIPAddress",
                typeof(IPAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                keyComparer: new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 45),
                converter: new ValueConverter<IPAddress, string>(
                    (IPAddress v) => v.ToString(),
                    (string v) => IPAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v))));

            var nullableIPAddressArray = runtimeEntityType.AddProperty(
                "NullableIPAddressArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableIPAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var nullableInt16 = runtimeEntityType.AddProperty(
                "NullableInt16",
                typeof(short?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16.TypeMapping = ShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                keyComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                providerValueComparer: new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt16Array = runtimeEntityType.AddProperty(
                "NullableInt16Array",
                typeof(short?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                keyComparer: new NullableValueTypeListComparer<short>(new ValueComparer<short?>(
                    (Nullable<short> v1, Nullable<short> v2) => v1.HasValue && v2.HasValue && (short)v1 == (short)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<short> v) => v.HasValue ? (int)(short)v : 0,
                    (Nullable<short> v) => v.HasValue ? (Nullable<short>)(short)v : default(Nullable<short>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short?>(new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<short?[], short?[], short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableInt32 = runtimeEntityType.AddProperty(
                "NullableInt32",
                typeof(int?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt32Array = runtimeEntityType.AddProperty(
                "NullableInt32Array",
                typeof(int?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                keyComparer: new NullableValueTypeListComparer<int>(new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<int?>(new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<int?[], int?[], int>(
                    JsonInt32ReaderWriter.Instance),
                elementMapping: IntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    keyComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    providerValueComparer: new ValueComparer<int>(
                        (int v1, int v2) => v1 == v2,
                        (int v) => v,
                        (int v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableInt64 = runtimeEntityType.AddProperty(
                "NullableInt64",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt64Array = runtimeEntityType.AddProperty(
                "NullableInt64Array",
                typeof(long?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                keyComparer: new NullableValueTypeListComparer<long>(new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<long?>(new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<long?[], long?[], long>(
                    JsonInt64ReaderWriter.Instance),
                elementMapping: LongTypeMapping.Default.Clone(
                    comparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    keyComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    providerValueComparer: new ValueComparer<long>(
                        (long v1, long v2) => v1 == v2,
                        (long v) => v.GetHashCode(),
                        (long v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableInt8 = runtimeEntityType.AddProperty(
                "NullableInt8",
                typeof(sbyte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8.TypeMapping = SByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                keyComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                providerValueComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableInt8Array = runtimeEntityType.AddProperty(
                "NullableInt8Array",
                typeof(sbyte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableInt8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                keyComparer: new NullableValueTypeListComparer<sbyte>(new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<sbyte?>(new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    JsonSByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<sbyte?[], sbyte?[], sbyte>(
                    JsonSByteReaderWriter.Instance),
                elementMapping: SByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    keyComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    providerValueComparer: new ValueComparer<sbyte>(
                        (sbyte v1, sbyte v2) => v1 == v2,
                        (sbyte v) => (int)v,
                        (sbyte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                "NullablePhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 20),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));

            var nullablePhysicalAddressArray = runtimeEntityType.AddProperty(
                "NullablePhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullablePhysicalAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 20),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));

            var nullableString = runtimeEntityType.AddProperty(
                "NullableString",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableString.TypeMapping = SqliteStringTypeMapping.Default;

            var nullableStringArray = runtimeEntityType.AddProperty(
                "NullableStringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableStringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var nullableTimeOnly = runtimeEntityType.AddProperty(
                "NullableTimeOnly",
                typeof(TimeOnly?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnly.TypeMapping = SqliteTimeOnlyTypeMapping.Default;

            var nullableTimeOnlyArray = runtimeEntityType.AddProperty(
                "NullableTimeOnlyArray",
                typeof(TimeOnly?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                keyComparer: new NullableValueTypeListComparer<TimeOnly>(new ValueComparer<TimeOnly?>(
                    (Nullable<TimeOnly> v1, Nullable<TimeOnly> v2) => v1.HasValue && v2.HasValue && (TimeOnly)v1 == (TimeOnly)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeOnly> v) => v.HasValue ? ((TimeOnly)v).GetHashCode() : 0,
                    (Nullable<TimeOnly> v) => v.HasValue ? (Nullable<TimeOnly>)(TimeOnly)v : default(Nullable<TimeOnly>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeOnly?>(new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeOnly?[], TimeOnly?[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqliteTimeOnlyTypeMapping.Default);

            var nullableTimeSpan = runtimeEntityType.AddProperty(
                "NullableTimeSpan",
                typeof(TimeSpan?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpan.TypeMapping = TimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                keyComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                providerValueComparer: new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var nullableTimeSpanArray = runtimeEntityType.AddProperty(
                "NullableTimeSpanArray",
                typeof(TimeSpan?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableTimeSpanArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                keyComparer: new NullableValueTypeListComparer<TimeSpan>(new ValueComparer<TimeSpan?>(
                    (Nullable<TimeSpan> v1, Nullable<TimeSpan> v2) => v1.HasValue && v2.HasValue && (TimeSpan)v1 == (TimeSpan)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<TimeSpan> v) => v.HasValue ? ((TimeSpan)v).GetHashCode() : 0,
                    (Nullable<TimeSpan> v) => v.HasValue ? (Nullable<TimeSpan>)(TimeSpan)v : default(Nullable<TimeSpan>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeSpan?>(new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<TimeSpan?[], TimeSpan?[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: TimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var nullableUInt16 = runtimeEntityType.AddProperty(
                "NullableUInt16",
                typeof(ushort?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                keyComparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                providerValueComparer: new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableUInt16Array = runtimeEntityType.AddProperty(
                "NullableUInt16Array",
                typeof(ushort?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                keyComparer: new NullableValueTypeListComparer<ushort>(new ValueComparer<ushort?>(
                    (Nullable<ushort> v1, Nullable<ushort> v2) => v1.HasValue && v2.HasValue && (ushort)v1 == (ushort)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ushort> v) => v.HasValue ? (int)(ushort)v : 0,
                    (Nullable<ushort> v) => v.HasValue ? (Nullable<ushort>)(ushort)v : default(Nullable<ushort>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ushort?>(new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    JsonUInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ushort?[], ushort?[], ushort>(
                    JsonUInt16ReaderWriter.Instance),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableUInt32 = runtimeEntityType.AddProperty(
                "NullableUInt32",
                typeof(uint?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableUInt32Array = runtimeEntityType.AddProperty(
                "NullableUInt32Array",
                typeof(uint?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                keyComparer: new NullableValueTypeListComparer<uint>(new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<uint?>(new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    JsonUInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<uint?[], uint?[], uint>(
                    JsonUInt32ReaderWriter.Instance),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableUInt64 = runtimeEntityType.AddProperty(
                "NullableUInt64",
                typeof(ulong?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64.TypeMapping = SqliteULongTypeMapping.Default;

            var nullableUInt64Array = runtimeEntityType.AddProperty(
                "NullableUInt64Array",
                typeof(ulong?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                keyComparer: new NullableValueTypeListComparer<ulong>(new ValueComparer<ulong?>(
                    (Nullable<ulong> v1, Nullable<ulong> v2) => v1.HasValue && v2.HasValue && (ulong)v1 == (ulong)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<ulong> v) => v.HasValue ? ((ulong)v).GetHashCode() : 0,
                    (Nullable<ulong> v) => v.HasValue ? (Nullable<ulong>)(ulong)v : default(Nullable<ulong>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ulong?>(new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    JsonUInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<ulong?[], ulong?[], ulong>(
                    JsonUInt64ReaderWriter.Instance),
                elementMapping: SqliteULongTypeMapping.Default);

            var nullableUInt8 = runtimeEntityType.AddProperty(
                "NullableUInt8",
                typeof(byte?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                keyComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                providerValueComparer: new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var nullableUInt8Array = runtimeEntityType.AddProperty(
                "NullableUInt8Array",
                typeof(byte?[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUInt8Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                keyComparer: new NullableValueTypeListComparer<byte>(new ValueComparer<byte?>(
                    (Nullable<byte> v1, Nullable<byte> v2) => v1.HasValue && v2.HasValue && (byte)v1 == (byte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<byte> v) => v.HasValue ? (int)(byte)v : 0,
                    (Nullable<byte> v) => v.HasValue ? (Nullable<byte>)(byte)v : default(Nullable<byte>))),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte?>(new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonNullableStructCollectionReaderWriter<byte?[], byte?[], byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var nullableUri = runtimeEntityType.AddProperty(
                "NullableUri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUri.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var nullableUriArray = runtimeEntityType.AddProperty(
                "NullableUriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nullableUriArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));

            var physicalAddress = runtimeEntityType.AddProperty(
                "PhysicalAddress",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddress.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 20),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));

            var physicalAddressArray = runtimeEntityType.AddProperty(
                "PhysicalAddressArray",
                typeof(PhysicalAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            physicalAddressArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                keyComparer: new ListComparer<PhysicalAddress>(new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<PhysicalAddress[], PhysicalAddress[], PhysicalAddress>(
                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    keyComparer: new ValueComparer<PhysicalAddress>(
                        (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                        (PhysicalAddress v) => v.GetHashCode(),
                        (PhysicalAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 20),
                    converter: new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<PhysicalAddress, string>(
                            (PhysicalAddress v) => v.ToString(),
                            (string v) => PhysicalAddress.Parse(v)))));

            var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                "PhysicalAddressToBytesConverterProperty",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new PhysicalAddressToBytesConverter());
            physicalAddressToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 8),
                converter: new ValueConverter<PhysicalAddress, byte[]>(
                    (PhysicalAddress v) => v.GetAddressBytes(),
                    (Byte[] v) => new PhysicalAddress(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, byte[]>(
                        (PhysicalAddress v) => v.GetAddressBytes(),
                        (Byte[] v) => new PhysicalAddress(v))));

            var physicalAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                "PhysicalAddressToStringConverterProperty",
                typeof(PhysicalAddress),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("PhysicalAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<PhysicalAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new PhysicalAddressToStringConverter());
            physicalAddressToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                keyComparer: new ValueComparer<PhysicalAddress>(
                    (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
                    (PhysicalAddress v) => v.GetHashCode(),
                    (PhysicalAddress v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 20),
                converter: new ValueConverter<PhysicalAddress, string>(
                    (PhysicalAddress v) => v.ToString(),
                    (string v) => PhysicalAddress.Parse(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<PhysicalAddress, string>(
                        (PhysicalAddress v) => v.ToString(),
                        (string v) => PhysicalAddress.Parse(v))));

            var @string = runtimeEntityType.AddProperty(
                "String",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("String", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<String>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            @string.TypeMapping = SqliteStringTypeMapping.Default;

            var stringArray = runtimeEntityType.AddProperty(
                "StringArray",
                typeof(string[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<string[], string[], string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                "StringToBoolConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToBoolConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToBoolConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToBoolConverter());
            stringToBoolConverterProperty.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<string, bool>(
                    (string v) => Convert.ToBoolean(v),
                    (bool v) => Convert.ToString(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, bool>(
                    JsonBoolReaderWriter.Instance,
                    new ValueConverter<string, bool>(
                        (string v) => Convert.ToBoolean(v),
                        (bool v) => Convert.ToString(v))));

            var stringToBytesConverterProperty = runtimeEntityType.AddProperty(
                "StringToBytesConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringToBytesConverterProperty.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                converter: new ValueConverter<string, byte[]>(
                    (string v) => Encoding.UTF32.GetBytes(v),
                    (Byte[] v) => Encoding.UTF32.GetString(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, byte[]>(
                    SqliteJsonByteArrayReaderWriter.Instance,
                    new ValueConverter<string, byte[]>(
                        (string v) => Encoding.UTF32.GetBytes(v),
                        (Byte[] v) => Encoding.UTF32.GetString(v))));

            var stringToCharConverterProperty = runtimeEntityType.AddProperty(
                "StringToCharConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToCharConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToCharConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToCharConverter());
            stringToCharConverterProperty.TypeMapping = CharTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<char>(
                    (char v1, char v2) => v1 == v2,
                    (char v) => (int)v,
                    (char v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT",
                    size: 1),
                converter: new ValueConverter<string, char>(
                    (string v) => v.Length < 1 ? '\0' : v[0],
                    (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, char>(
                    JsonCharReaderWriter.Instance,
                    new ValueConverter<string, char>(
                        (string v) => v.Length < 1 ? '\0' : v[0],
                        (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v))));

            var stringToDateOnlyConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateOnlyConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToDateOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToDateOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToDateOnlyConverter());
            stringToDateOnlyConverterProperty.TypeMapping = SqliteDateOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<DateOnly>(
                    (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                    (DateOnly v) => v.GetHashCode(),
                    (DateOnly v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 10),
                converter: new ValueConverter<string, DateOnly>(
                    (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                    (DateOnly v) => v.ToString("yyyy\\-MM\\-dd")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateOnly>(
                    JsonDateOnlyReaderWriter.Instance,
                    new ValueConverter<string, DateOnly>(
                        (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                        (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"))));

            var stringToDateTimeConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateTimeConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToDateTimeConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToDateTimeConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToDateTimeConverter());
            stringToDateTimeConverterProperty.TypeMapping = SqliteDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, DateTime>(
                    (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
                    (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance,
                    new ValueConverter<string, DateTime>(
                        (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
                        (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"))));

            var stringToDateTimeOffsetConverterProperty = runtimeEntityType.AddProperty(
                "StringToDateTimeOffsetConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToDateTimeOffsetConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToDateTimeOffsetConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToDateTimeOffsetConverter());
            stringToDateTimeOffsetConverterProperty.TypeMapping = SqliteDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<DateTimeOffset>(
                    (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
                    (DateTimeOffset v) => v.GetHashCode(),
                    (DateTimeOffset v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, DateTimeOffset>(
                    (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
                    (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTimeOffset>(
                    SqliteJsonDateTimeOffsetReaderWriter.Instance,
                    new ValueConverter<string, DateTimeOffset>(
                        (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
                        (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"))));

            var stringToDecimalNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToDecimalNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToDecimalNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToDecimalNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToNumberConverter<decimal>());
            stringToDecimalNumberConverterProperty.TypeMapping = SqliteDecimalTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<decimal>(
                    (decimal v1, decimal v2) => v1 == v2,
                    (decimal v) => v.GetHashCode(),
                    (decimal v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 64),
                converter: new ValueConverter<string, decimal>(
                    (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, decimal>(
                    SqliteJsonDecimalReaderWriter.Instance,
                    new ValueConverter<string, decimal>(
                        (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v))));

            var stringToDoubleNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToDoubleNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToDoubleNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToDoubleNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToNumberConverter<double>());
            stringToDoubleNumberConverterProperty.TypeMapping = DoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<double>(
                    (double v1, double v2) => v1.Equals(v2),
                    (double v) => v.GetHashCode(),
                    (double v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "REAL",
                    size: 64),
                converter: new ValueConverter<string, double>(
                    (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, double>(
                    JsonDoubleReaderWriter.Instance,
                    new ValueConverter<string, double>(
                        (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", (object)v))));

            var stringToEnumConverterProperty = runtimeEntityType.AddProperty(
                "StringToEnumConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToEnumConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToEnumConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToEnumConverter<CSharpRuntimeModelCodeGeneratorTest.EnumU32>());
            stringToEnumConverterProperty.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<string, uint>(
                    (string v) => (uint)StringEnumConverter<string, CSharpRuntimeModelCodeGeneratorTest.EnumU32, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v),
                    (uint value) => ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)value).ToString()),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, uint>(
                    JsonUInt32ReaderWriter.Instance,
                    new ValueConverter<string, uint>(
                        (string v) => (uint)StringEnumConverter<string, CSharpRuntimeModelCodeGeneratorTest.EnumU32, CSharpRuntimeModelCodeGeneratorTest.EnumU32>.ConvertToEnum(v),
                        (uint value) => ((CSharpRuntimeModelCodeGeneratorTest.EnumU32)value).ToString())));

            var stringToGuidConverterProperty = runtimeEntityType.AddProperty(
                "StringToGuidConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToGuidConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToGuidConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stringToGuidConverterProperty.TypeMapping = SqliteStringTypeMapping.Default;

            var stringToIntNumberConverterProperty = runtimeEntityType.AddProperty(
                "StringToIntNumberConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToIntNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToIntNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToNumberConverter<int>());
            stringToIntNumberConverterProperty.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER",
                    size: 64),
                converter: new ValueConverter<string, int>(
                    (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                    (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<string, int>(
                        (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
                        (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", (object)v))));

            var stringToTimeOnlyConverterProperty = runtimeEntityType.AddProperty(
                "StringToTimeOnlyConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToTimeOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToTimeOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToTimeOnlyConverter());
            stringToTimeOnlyConverterProperty.TypeMapping = SqliteTimeOnlyTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<string, TimeOnly>(
                    (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                    (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance,
                    new ValueConverter<string, TimeOnly>(
                        (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
                        (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o"))));

            var stringToTimeSpanConverterProperty = runtimeEntityType.AddProperty(
                "StringToTimeSpanConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToTimeSpanConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToTimeSpanConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToTimeSpanConverter());
            stringToTimeSpanConverterProperty.TypeMapping = TimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT",
                    size: 48),
                converter: new ValueConverter<string, TimeSpan>(
                    (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
                    (TimeSpan v) => v.ToString("c")),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance,
                    new ValueConverter<string, TimeSpan>(
                        (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
                        (TimeSpan v) => v.ToString("c"))));

            var stringToUriConverterProperty = runtimeEntityType.AddProperty(
                "StringToUriConverterProperty",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("StringToUriConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<StringToUriConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new StringToUriConverter());
            stringToUriConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<string, string>(
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString()),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<string, string>(
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute).ToString())));

            var timeOnly = runtimeEntityType.AddProperty(
                "TimeOnly",
                typeof(TimeOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeOnly(0, 0, 0));
            timeOnly.TypeMapping = SqliteTimeOnlyTypeMapping.Default;

            var timeOnlyArray = runtimeEntityType.AddProperty(
                "TimeOnlyArray",
                typeof(TimeOnly[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeOnlyArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                keyComparer: new ListComparer<TimeOnly>(new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeOnly>(new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeOnly[], TimeOnly[], TimeOnly>(
                    JsonTimeOnlyReaderWriter.Instance),
                elementMapping: SqliteTimeOnlyTypeMapping.Default);

            var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                "TimeOnlyToStringConverterProperty",
                typeof(TimeOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeOnlyToStringConverter());
            timeOnlyToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<TimeOnly, string>(
                    (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o"),
                    (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<TimeOnly, string>(
                        (TimeOnly v) => v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", (object)v) : v.ToString("o"),
                        (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
            timeOnlyToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");

            var timeOnlyToTicksConverterProperty = runtimeEntityType.AddProperty(
                "TimeOnlyToTicksConverterProperty",
                typeof(TimeOnly),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeOnlyToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeOnlyToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeOnlyToTicksConverter());
            timeOnlyToTicksConverterProperty.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                keyComparer: new ValueComparer<TimeOnly>(
                    (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                    (TimeOnly v) => v.GetHashCode(),
                    (TimeOnly v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<TimeOnly, long>(
                    (TimeOnly v) => v.Ticks,
                    (long v) => new TimeOnly(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<TimeOnly, long>(
                        (TimeOnly v) => v.Ticks,
                        (long v) => new TimeOnly(v))));
            timeOnlyToTicksConverterProperty.SetSentinelFromProviderValue(0L);

            var timeSpan = runtimeEntityType.AddProperty(
                "TimeSpan",
                typeof(TimeSpan),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new TimeSpan(0, 0, 0, 0, 0));
            timeSpan.TypeMapping = TimeSpanTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "TEXT"));

            var timeSpanArray = runtimeEntityType.AddProperty(
                "TimeSpanArray",
                typeof(TimeSpan[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            timeSpanArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                keyComparer: new ListComparer<TimeSpan>(new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<TimeSpan>(new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<TimeSpan[], TimeSpan[], TimeSpan>(
                    JsonTimeSpanReaderWriter.Instance),
                elementMapping: TimeSpanTypeMapping.Default.Clone(
                    comparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    keyComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    providerValueComparer: new ValueComparer<TimeSpan>(
                        (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                        (TimeSpan v) => v.GetHashCode(),
                        (TimeSpan v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "TEXT")));

            var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                "TimeSpanToStringConverterProperty",
                typeof(TimeSpan),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpanToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpanToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeSpanToStringConverter());
            timeSpanToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    size: 48),
                converter: new ValueConverter<TimeSpan, string>(
                    (TimeSpan v) => v.ToString("c"),
                    (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<TimeSpan, string>(
                        (TimeSpan v) => v.ToString("c"),
                        (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture))));
            timeSpanToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");

            var timeSpanToTicksConverterProperty = runtimeEntityType.AddProperty(
                "TimeSpanToTicksConverterProperty",
                typeof(TimeSpan),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("TimeSpanToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<TimeSpanToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueConverter: new TimeSpanToTicksConverter());
            timeSpanToTicksConverterProperty.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                keyComparer: new ValueComparer<TimeSpan>(
                    (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                    (TimeSpan v) => v.GetHashCode(),
                    (TimeSpan v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<TimeSpan, long>(
                    (TimeSpan v) => v.Ticks,
                    (long v) => new TimeSpan(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, long>(
                    JsonInt64ReaderWriter.Instance,
                    new ValueConverter<TimeSpan, long>(
                        (TimeSpan v) => v.Ticks,
                        (long v) => new TimeSpan(v))));
            timeSpanToTicksConverterProperty.SetSentinelFromProviderValue(0L);

            var uInt16 = runtimeEntityType.AddProperty(
                "UInt16",
                typeof(ushort),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            uInt16.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var uInt16Array = runtimeEntityType.AddProperty(
                "UInt16Array",
                typeof(ushort[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt16Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                keyComparer: new ListComparer<ushort>(new ValueComparer<ushort>(
                    (ushort v1, ushort v2) => v1 == v2,
                    (ushort v) => (int)v,
                    (ushort v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ushort>(new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    JsonUInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ushort[], ushort[], ushort>(
                    JsonUInt16ReaderWriter.Instance),
                elementMapping: UShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    keyComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    providerValueComparer: new ValueComparer<ushort>(
                        (ushort v1, ushort v2) => v1 == v2,
                        (ushort v) => (int)v,
                        (ushort v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var uInt32 = runtimeEntityType.AddProperty(
                "UInt32",
                typeof(uint),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            uInt32.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var uInt32Array = runtimeEntityType.AddProperty(
                "UInt32Array",
                typeof(uint[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt32Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                keyComparer: new ListComparer<uint>(new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<uint>(new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    JsonUInt32ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<uint[], uint[], uint>(
                    JsonUInt32ReaderWriter.Instance),
                elementMapping: UIntTypeMapping.Default.Clone(
                    comparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    keyComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    providerValueComparer: new ValueComparer<uint>(
                        (uint v1, uint v2) => v1 == v2,
                        (uint v) => (int)v,
                        (uint v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var uInt64 = runtimeEntityType.AddProperty(
                "UInt64",
                typeof(ulong),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0ul);
            uInt64.TypeMapping = SqliteULongTypeMapping.Default;

            var uInt64Array = runtimeEntityType.AddProperty(
                "UInt64Array",
                typeof(ulong[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt64Array.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                keyComparer: new ListComparer<ulong>(new ValueComparer<ulong>(
                    (ulong v1, ulong v2) => v1 == v2,
                    (ulong v) => v.GetHashCode(),
                    (ulong v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<ulong>(new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    JsonUInt64ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<ulong[], ulong[], ulong>(
                    JsonUInt64ReaderWriter.Instance),
                elementMapping: SqliteULongTypeMapping.Default);

            var uInt8 = runtimeEntityType.AddProperty(
                "UInt8",
                typeof(byte),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (byte)0);
            uInt8.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                keyComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var uInt8Array = runtimeEntityType.AddProperty(
                "UInt8Array",
                typeof(byte[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uInt8Array.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var uri = runtimeEntityType.AddProperty(
                "Uri",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("Uri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<Uri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uri.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var uriArray = runtimeEntityType.AddProperty(
                "UriArray",
                typeof(Uri[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uriArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                keyComparer: new ListComparer<Uri>(new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<Uri[], Uri[], Uri>(
                    new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    keyComparer: new ValueComparer<Uri>(
                        (Uri v1, Uri v2) => v1 == v2,
                        (Uri v) => v.GetHashCode(),
                        (Uri v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    converter: new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<Uri, string>(
                            (Uri v) => v.ToString(),
                            (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));

            var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                "UriToStringConverterProperty",
                typeof(Uri),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetProperty("UriToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.ManyTypes).GetField("<UriToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                valueConverter: new UriToStringConverter());
            uriToStringConverterProperty.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    (Uri v1, Uri v2) => v1 == v2,
                    (Uri v) => v.GetHashCode(),
                    (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    (Uri v) => v.ToString(),
                    (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        (Uri v) => v.ToString(),
                        (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyTypes");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBaseEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Json.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NetTopologySuite.Geometries;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class PrincipalBaseEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase),
                baseEntityType,
                discriminatorValue: "PrincipalBase");

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            id.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var idPrincipalDerived = new RuntimeRelationalPropertyOverrides(
                id,
                StoreObjectIdentifier.Table("PrincipalDerived", null),
                true,
                "DerivedId");
            overrides.Add(StoreObjectIdentifier.Table("PrincipalDerived", null), idPrincipalDerived);
            id.AddAnnotation("Relational:RelationalOverrides", overrides);


            var alternateId = runtimeEntityType.AddProperty(
                "AlternateId",
                typeof(Guid),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("AlternateId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.FieldDuringConstruction,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"),
                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
            alternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var enum1 = runtimeEntityType.AddProperty(
                "Enum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            enum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v1, CSharpRuntimeModelCodeGeneratorTest.AnEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));
            enum1.SetSentinelFromProviderValue(0);

            var enum2 = runtimeEntityType.AddProperty(
                "Enum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AnEnum?),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            enum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AnEnum?>(
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v1, Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v2) => v1.HasValue && v2.HasValue && object.Equals((object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v1, (object)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? ((CSharpRuntimeModelCodeGeneratorTest.AnEnum)v).GetHashCode() : 0,
                    (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum> v) => v.HasValue ? (Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)(CSharpRuntimeModelCodeGeneratorTest.AnEnum)v : default(Nullable<CSharpRuntimeModelCodeGeneratorTest.AnEnum>)),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AnEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AnEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AnEnum)value)));

            var flagsEnum1 = runtimeEntityType.AddProperty(
                "FlagsEnum1",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            flagsEnum1.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum1.SetSentinelFromProviderValue(0);

            var flagsEnum2 = runtimeEntityType.AddProperty(
                "FlagsEnum2",
                typeof(CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("FlagsEnum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            flagsEnum2.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                keyComparer: new ValueComparer<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v1, CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v2) => object.Equals((object)v1, (object)v2),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v.GetHashCode(),
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                    (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum, int>(
                        (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum value) => (int)value,
                        (int value) => (CSharpRuntimeModelCodeGeneratorTest.AFlagsEnum)value)));
            flagsEnum2.SetSentinelFromProviderValue(6);

            var point = runtimeEntityType.AddProperty(
                "Point",
                typeof(Point),
                nullable: true,
                valueGenerated: ValueGenerated.OnAdd,
                valueConverter: new CastingConverter<Point, Point>(),
                valueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>(),
                providerValueComparer: new CSharpRuntimeModelCodeGeneratorTest.CustomValueComparer<Point>());
            point.TypeMapping = null;
            point.AddAnnotation("Relational:ColumnType", "geometry");
            point.AddAnnotation("Relational:DefaultValue", (NetTopologySuite.Geometries.Point)new NetTopologySuite.IO.WKTReader().Read("SRID=0;POINT Z(0 0 0)"));

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var key = runtimeEntityType.AddKey(
                new[] { id });

            var key0 = runtimeEntityType.AddKey(
                new[] { id, alternateId });
            runtimeEntityType.SetPrimaryKey(key0);
            key0.AddAnnotation("Relational:Name", "PK");

            var index = runtimeEntityType.AddIndex(
                new[] { alternateId, id });

            return runtimeEntityType;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Deriveds",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("PrincipalsId"), joinEntityType.FindProperty("PrincipalsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Deriveds", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var inverse = targetEntityType.FindSkipNavigation("Principals");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:MappingStrategy", "TPT");
            runtimeEntityType.AddAnnotation("Relational:Schema", "mySchema");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedTypeEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Json.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class OwnedTypeEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalBase.Owned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true,
                changeTrackingStrategy: ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);

            var principalBaseId = runtimeEntityType.AddProperty(
                "PrincipalBaseId",
                typeof(long),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalBaseId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var overrides = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var principalBaseIdPrincipalBase = new RuntimeRelationalPropertyOverrides(
                principalBaseId,
                StoreObjectIdentifier.Table("PrincipalBase", "mySchema"),
                false,
                null);
            principalBaseIdPrincipalBase.AddAnnotation("SqlServer:IdentityIncrement", 3);
            principalBaseIdPrincipalBase.AddAnnotation("SqlServer:IdentitySeed", 2L);
            principalBaseIdPrincipalBase.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
            overrides.Add(StoreObjectIdentifier.Table("PrincipalBase", "mySchema"), principalBaseIdPrincipalBase);
            principalBaseId.AddAnnotation("Relational:RelationalOverrides", overrides);


            var principalBaseAlternateId = runtimeEntityType.AddProperty(
                "PrincipalBaseAlternateId",
                typeof(Guid),
                propertyAccessMode: PropertyAccessMode.Field,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalBaseAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            details.TypeMapping = SqliteStringTypeMapping.Default;

            var overrides0 = new StoreObjectDictionary<RuntimeRelationalPropertyOverrides>();
            var detailsDetails = new RuntimeRelationalPropertyOverrides(
                details,
                StoreObjectIdentifier.Table("Details", null),
                false,
                null);
            overrides0.Add(StoreObjectIdentifier.Table("Details", null), detailsDetails);
            details.AddAnnotation("Relational:RelationalOverrides", overrides0);


            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            refTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                nullable: true);
            valueTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalBaseId, principalBaseAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId"), declaringEntityType.FindProperty("PrincipalBaseAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true,
                ownership: true);

            var owned = principalEntityType.AddNavigation("Owned",
                runtimeForeignKey,
                onDependent: false,
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetProperty("Owned", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalBase).GetField("_ownedField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                propertyAccessMode: PropertyAccessMode.Field,
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalBaseId"), declaringEntityType.FindProperty("PrincipalBaseAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("PrincipalBaseId"), principalEntityType.FindProperty("PrincipalBaseAlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true,
                requiredDependent: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var fragments = new StoreObjectDictionary<RuntimeEntityTypeMappingFragment>();
            var detailsFragment = new RuntimeEntityTypeMappingFragment(
                runtimeEntityType,
                StoreObjectIdentifier.Table("Details", null),
                null);
            fragments.Add(StoreObjectIdentifier.Table("Details", null), detailsFragment);
            runtimeEntityType.AddAnnotation("Relational:MappingFragments", fragments);
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", "mySchema");
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBase");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "OwnedType0EntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Json.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class OwnedType0EntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>.ManyOwned#OwnedType",
                typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType),
                baseEntityType,
                sharedClrType: true);

            var principalDerivedId = runtimeEntityType.AddProperty(
                "PrincipalDerivedId",
                typeof(long),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            principalDerivedId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var principalDerivedAlternateId = runtimeEntityType.AddProperty(
                "PrincipalDerivedAlternateId",
                typeof(Guid),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            principalDerivedAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var details = runtimeEntityType.AddProperty(
                "Details",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            details.TypeMapping = SqliteStringTypeMapping.Default;

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0);
            number.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                keyComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    (int v1, int v2) => v1 == v2,
                    (int v) => v,
                    (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var refTypeArray = runtimeEntityType.AddProperty(
                "RefTypeArray",
                typeof(IPAddress[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IPAddress[], IPAddress[], IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var refTypeEnumerable = runtimeEntityType.AddProperty(
                "RefTypeEnumerable",
                typeof(IEnumerable<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeIList = runtimeEntityType.AddProperty(
                "RefTypeIList",
                typeof(IList<string>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                keyComparer: new ListComparer<string>(new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<string>, List<string>, string>(
                    JsonStringReaderWriter.Instance),
                elementMapping: SqliteStringTypeMapping.Default);

            var refTypeList = runtimeEntityType.AddProperty(
                "RefTypeList",
                typeof(List<IPAddress>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            refTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                keyComparer: new ListComparer<IPAddress>(new ValueComparer<IPAddress>(
                    (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    (IPAddress v) => v.GetHashCode(),
                    (IPAddress v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v))))),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<IPAddress>, List<IPAddress>, IPAddress>(
                    new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))),
                elementMapping: SqliteStringTypeMapping.Default.Clone(
                    comparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    keyComparer: new ValueComparer<IPAddress>(
                        (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                        (IPAddress v) => v.GetHashCode(),
                        (IPAddress v) => v),
                    providerValueComparer: new ValueComparer<string>(
                        (string v1, string v2) => v1 == v2,
                        (string v) => v.GetHashCode(),
                        (string v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        size: 45),
                    converter: new ValueConverter<IPAddress, string>(
                        (IPAddress v) => v.ToString(),
                        (string v) => IPAddress.Parse(v)),
                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
                        JsonStringReaderWriter.Instance,
                        new ValueConverter<IPAddress, string>(
                            (IPAddress v) => v.ToString(),
                            (string v) => IPAddress.Parse(v)))));

            var valueTypeArray = runtimeEntityType.AddProperty(
                "ValueTypeArray",
                typeof(DateTime[]),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeArray.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                keyComparer: new ListComparer<DateTime>(new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<DateTime[], DateTime[], DateTime>(
                    SqliteJsonDateTimeReaderWriter.Instance),
                elementMapping: SqliteDateTimeTypeMapping.Default);

            var valueTypeEnumerable = runtimeEntityType.AddProperty(
                "ValueTypeEnumerable",
                typeof(IEnumerable<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeEnumerable.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IEnumerable<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeIList = runtimeEntityType.AddProperty(
                "ValueTypeIList",
                typeof(IList<byte>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeIList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                keyComparer: new ListComparer<byte>(new ValueComparer<byte>(
                    (byte v1, byte v2) => v1 == v2,
                    (byte v) => (int)v,
                    (byte v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<IList<byte>, List<byte>, byte>(
                    JsonByteReaderWriter.Instance),
                elementMapping: ByteTypeMapping.Default.Clone(
                    comparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    keyComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    providerValueComparer: new ValueComparer<byte>(
                        (byte v1, byte v2) => v1 == v2,
                        (byte v) => (int)v,
                        (byte v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var valueTypeList = runtimeEntityType.AddProperty(
                "ValueTypeList",
                typeof(List<short>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            valueTypeList.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                keyComparer: new ListComparer<short>(new ValueComparer<short>(
                    (short v1, short v2) => v1 == v2,
                    (short v) => (int)v,
                    (short v) => v)),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance)),
                jsonValueReaderWriter: new JsonCollectionReaderWriter<List<short>, List<short>, short>(
                    JsonInt16ReaderWriter.Instance),
                elementMapping: ShortTypeMapping.Default.Clone(
                    comparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    keyComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    providerValueComparer: new ValueComparer<short>(
                        (short v1, short v2) => v1 == v2,
                        (short v) => (int)v,
                        (short v) => v),
                    mappingInfo: new RelationalTypeMappingInfo(
                        storeTypeName: "INTEGER")));

            var context = runtimeEntityType.AddServiceProperty(
                "Context",
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                serviceType: typeof(DbContext));

            var key = runtimeEntityType.AddKey(
                new[] { principalDerivedId, principalDerivedAlternateId, id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalDerivedId"), declaringEntityType.FindProperty("PrincipalDerivedAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true,
                ownership: true);

            var manyOwned = principalEntityType.AddNavigation("ManyOwned",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.OwnedType>),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("ManyOwned", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ManyOwned");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);
            runtimeEntityType.AddAnnotation("SqlServer:MemoryOptimized", true);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class PrincipalBasePrincipalDerivedDependentBasebyteEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                typeof(Dictionary<string, object>),
                baseEntityType,
                sharedClrType: true,
                indexerPropertyInfo: RuntimeEntityType.FindIndexerProperty(typeof(Dictionary<string, object>)),
                propertyBag: true);

            var derivedsId = runtimeEntityType.AddProperty(
                "DerivedsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var derivedsAlternateId = runtimeEntityType.AddProperty(
                "DerivedsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            derivedsAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var principalsId = runtimeEntityType.AddProperty(
                "PrincipalsId",
                typeof(long),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsId.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                keyComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    (long v1, long v2) => v1 == v2,
                    (long v) => v.GetHashCode(),
                    (long v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var principalsAlternateId = runtimeEntityType.AddProperty(
                "PrincipalsAlternateId",
                typeof(Guid),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                afterSaveBehavior: PropertySaveBehavior.Throw);
            principalsAlternateId.TypeMapping = SqliteGuidTypeMapping.Default;

            var rowid = runtimeEntityType.AddProperty(
                "rowid",
                typeof(byte[]),
                propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                nullable: true,
                concurrencyToken: true,
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore);
            rowid.TypeMapping = SqliteByteArrayTypeMapping.Default.Clone(
                comparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => v.GetHashCode(),
                    (Byte[] v) => v),
                keyComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()),
                providerValueComparer: new ValueComparer<byte[]>(
                    (Byte[] v1, Byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals((object)v1, (object)v2),
                    (Byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode((object)v),
                    (Byte[] source) => source.ToArray()));

            var key = runtimeEntityType.AddKey(
                new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { principalsId, principalsAlternateId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("DerivedsId"), declaringEntityType.FindProperty("DerivedsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("PrincipalsId"), declaringEntityType.FindProperty("PrincipalsAlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalBasePrincipalDerived<DependentBase<byte?>>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "DependentDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Migrations.Design;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class DependentDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentDerived<byte?>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>),
                baseEntityType,
                discriminatorProperty: "EnumDiscriminator",
                discriminatorValue: CSharpMigrationsGeneratorTest.Enum1.Two);

            var data = runtimeEntityType.AddProperty(
                "Data",
                typeof(string),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetProperty("Data", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.DependentDerived<byte?>).GetField("<Data>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 20,
                unicode: false);
            data.TypeMapping = SqliteStringTypeMapping.Default;
            data.AddAnnotation("Relational:IsFixedLength", true);

            var money = runtimeEntityType.AddProperty(
                "Money",
                typeof(decimal),
                precision: 9,
                scale: 3,
                sentinel: 0m);
            money.TypeMapping = SqliteDecimalTypeMapping.Default;

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "DependentBase<byte?>");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c),
                    c => AssertFileContents(
                        "PrincipalDerivedEntityType.cs",
                        """
// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Microsoft.EntityFrameworkCore.Metadata
{
    internal partial class PrincipalDerivedEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>),
                baseEntityType,
                discriminatorValue: "PrincipalDerived<DependentBase<byte?>>");

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id"), principalEntityType.FindProperty("AlternateId") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                unique: true,
                required: true);

            return runtimeForeignKey;
        }

        public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType declaringEntityType, RuntimeEntityType targetEntityType, RuntimeEntityType joinEntityType)
        {
            var skipNavigation = declaringEntityType.AddSkipNavigation(
                "Principals",
                targetEntityType,
                joinEntityType.FindForeignKey(
                    new[] { joinEntityType.FindProperty("DerivedsId"), joinEntityType.FindProperty("DerivedsAlternateId") },
                    declaringEntityType.FindKey(new[] { declaringEntityType.FindProperty("Id"), declaringEntityType.FindProperty("AlternateId") }),
                    declaringEntityType),
                true,
                false,
                typeof(ICollection<CSharpRuntimeModelCodeGeneratorTest.PrincipalBase>),
                propertyInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetProperty("Principals", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CSharpRuntimeModelCodeGeneratorTest.PrincipalDerived<CSharpRuntimeModelCodeGeneratorTest.DependentBase<byte?>>).GetField("<Principals>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true,
                lazyLoadingEnabled: false);

            var inverse = targetEntityType.FindSkipNavigation("Deriveds");
            if (inverse != null)
            {
                skipNavigation.Inverse = inverse;
                inverse.Inverse = skipNavigation;
            }

            return skipNavigation;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "PrincipalDerived");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
""", c)),
                model =>
                {
                    var dataEntity = model.FindEntityType(typeof(Data));

                    Assert.Equal(typeof(Data).FullName, dataEntity.Name);
                    Assert.False(dataEntity.HasSharedClrType);
                    Assert.False(dataEntity.IsPropertyBag);
                    Assert.False(dataEntity.IsOwned());
                    Assert.IsType<ConstructorBinding>(dataEntity.ConstructorBinding);
                    Assert.Null(dataEntity.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, dataEntity.GetChangeTrackingStrategy());
                    Assert.Equal("Data", dataEntity.GetTableName());
                    Assert.Null(dataEntity.GetSchema());

                    var point = dataEntity.FindProperty("Point");
                    Assert.Equal(typeof(Point), point.ClrType);
                    Assert.True(point.IsNullable);
                    Assert.Equal(ValueGenerated.Never, point.ValueGenerated);
                    Assert.Equal("Point", point.GetColumnName());
                    Assert.Equal("POINT", point.GetColumnType());
                    Assert.Null(point.GetValueConverter());
                    Assert.IsType<GeometryValueComparer<Point>>(point.GetValueComparer());
                    Assert.IsType<GeometryValueComparer<Point>>(point.GetKeyValueComparer());
                    Assert.Null(point.GetSrid());

                    var manyTypesType = model.FindEntityType(typeof(ManyTypes));

                    Assert.Equal(typeof(ManyTypes).FullName, manyTypesType.Name);
                    Assert.False(manyTypesType.HasSharedClrType);
                    Assert.False(manyTypesType.IsPropertyBag);
                    Assert.False(manyTypesType.IsOwned());
                    Assert.IsType<ConstructorBinding>(manyTypesType.ConstructorBinding);
                    Assert.Null(manyTypesType.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, manyTypesType.GetChangeTrackingStrategy());
                    Assert.Equal("ManyTypes", manyTypesType.GetTableName());
                    Assert.Null(manyTypesType.GetSchema());

                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetCollation()).Message);
                    Assert.Empty(model.GetAnnotations());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => model.GetPropertyAccessMode()).Message);

                    Assert.Null(model.FindEntityType(typeof(AbstractBase)));
                    var principalBase = model.FindEntityType(typeof(PrincipalBase));
                    Assert.Equal(typeof(PrincipalBase).FullName, principalBase.Name);
                    Assert.False(principalBase.HasSharedClrType);
                    Assert.False(principalBase.IsPropertyBag);
                    Assert.False(principalBase.IsOwned());
                    Assert.Null(principalBase.BaseType);
                    Assert.IsType<ConstructorBinding>(principalBase.ConstructorBinding);
                    Assert.Null(principalBase.FindIndexerPropertyInfo());
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalBase.GetChangeTrackingStrategy());
                    Assert.Null(principalBase.GetQueryFilter());
                    Assert.Equal("PrincipalBase", principalBase.GetTableName());
                    Assert.Equal("mySchema", principalBase.GetSchema());
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => principalBase.GetSeedData()).Message);

                    var principalId = principalBase.FindProperty(nameof(PrincipalBase.Id));
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.RelationalOverrides },
                        principalId.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(typeof(long?), principalId.ClrType);
                    Assert.Equal(typeof(long?), principalId.PropertyInfo.PropertyType);
                    Assert.Equal(typeof(long?), principalId.FieldInfo.FieldType);
                    Assert.False(principalId.IsNullable);
                    Assert.Equal(ValueGenerated.Never, principalId.ValueGenerated);
                    Assert.Equal(PropertySaveBehavior.Throw, principalId.GetAfterSaveBehavior());
                    Assert.Equal(PropertySaveBehavior.Save, principalId.GetBeforeSaveBehavior());
                    Assert.Null(principalId[CoreAnnotationNames.BeforeSaveBehavior]);
                    Assert.Null(principalId[CoreAnnotationNames.AfterSaveBehavior]);
                    Assert.Equal("Id", principalId.GetColumnName());
                    Assert.Equal("Id", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalBase", "mySchema")));
                    Assert.Equal("DerivedId", principalId.GetColumnName(StoreObjectIdentifier.Table("PrincipalDerived")));
                    Assert.Equal("INTEGER", principalId.GetColumnType());
                    Assert.Null(principalId.GetValueConverter());
                    Assert.NotNull(principalId.GetValueComparer());
                    Assert.NotNull(principalId.GetKeyValueComparer());

                    var pointProperty = principalBase.FindProperty("Point");
                    Assert.Equal(typeof(Point), pointProperty.ClrType);
                    Assert.True(pointProperty.IsNullable);
                    Assert.Equal(ValueGenerated.OnAdd, pointProperty.ValueGenerated);
                    Assert.Equal("Point", pointProperty.GetColumnName());
                    Assert.Equal("geometry", pointProperty.GetColumnType());
                    Assert.Equal(0, ((Point)pointProperty.GetDefaultValue()).SRID);
                    Assert.IsType<CastingConverter<Point, Point>>(pointProperty.GetValueConverter());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetKeyValueComparer());
                    Assert.IsType<CustomValueComparer<Point>>(pointProperty.GetProviderValueComparer());
                    Assert.Null(pointProperty[CoreAnnotationNames.PropertyAccessMode]);

                    Assert.Null(principalBase.FindDiscriminatorProperty());

                    var principalAlternateId = principalBase.FindProperty(nameof(PrincipalBase.AlternateId));
                    var compositeIndex = principalBase.GetIndexes().Single();
                    Assert.Equal(PropertyAccessMode.FieldDuringConstruction, principalAlternateId.GetPropertyAccessMode());
                    Assert.Empty(compositeIndex.GetAnnotations());
                    Assert.Equal(new[] { principalAlternateId, principalId }, compositeIndex.Properties);
                    Assert.False(compositeIndex.IsUnique);
                    Assert.Null(compositeIndex.Name);
                    Assert.Equal("IX_PrincipalBase_AlternateId_Id", compositeIndex.GetDatabaseName());

                    Assert.Equal(new[] { compositeIndex }, principalAlternateId.GetContainingIndexes());

                    Assert.Equal(2, principalBase.GetKeys().Count());

                    var principalAlternateKey = principalBase.GetKeys().First();
                    Assert.Same(principalId, principalAlternateKey.Properties.Single());
                    Assert.False(principalAlternateKey.IsPrimaryKey());
                    Assert.Equal("AK_PrincipalBase_Id", principalAlternateKey.GetName());

                    var principalKey = principalBase.GetKeys().Last();
                    Assert.Equal(
                        new[] { RelationalAnnotationNames.Name },
                        principalKey.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(new[] { principalId, principalAlternateId }, principalKey.Properties);
                    Assert.True(principalKey.IsPrimaryKey());
                    Assert.Equal("PK", principalKey.GetName());

                    Assert.Equal(new[] { principalAlternateKey, principalKey }, principalId.GetContainingKeys());

                    var referenceOwnedNavigation = principalBase.GetNavigations().Single();
                    Assert.Equal(
                        new[] { CoreAnnotationNames.EagerLoaded },
                        referenceOwnedNavigation.GetAnnotations().Select(a => a.Name));
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.Name);
                    Assert.False(referenceOwnedNavigation.IsCollection);
                    Assert.True(referenceOwnedNavigation.IsEagerLoaded);
                    Assert.False(referenceOwnedNavigation.IsOnDependent);
                    Assert.Equal(typeof(OwnedType), referenceOwnedNavigation.ClrType);
                    Assert.Equal("_ownedField", referenceOwnedNavigation.FieldInfo.Name);
                    Assert.Equal(nameof(PrincipalBase.Owned), referenceOwnedNavigation.PropertyInfo.Name);
                    Assert.Null(referenceOwnedNavigation.Inverse);
                    Assert.Equal(principalBase, referenceOwnedNavigation.DeclaringEntityType);
                    Assert.Equal(PropertyAccessMode.Field, referenceOwnedNavigation.GetPropertyAccessMode());
                    Assert.Null(referenceOwnedNavigation[CoreAnnotationNames.PropertyAccessMode]);

                    var referenceOwnedType = referenceOwnedNavigation.TargetEntityType;
                    Assert.Equal(typeof(PrincipalBase).FullName + ".Owned#OwnedType", referenceOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), referenceOwnedType.ClrType);
                    Assert.True(referenceOwnedType.HasSharedClrType);
                    Assert.False(referenceOwnedType.IsPropertyBag);
                    Assert.True(referenceOwnedType.IsOwned());
                    Assert.Null(referenceOwnedType.BaseType);
                    Assert.IsType<ConstructorBinding>(referenceOwnedType.ConstructorBinding);
                    Assert.Null(referenceOwnedType.FindIndexerPropertyInfo());
                    Assert.Equal(
                        ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues,
                        referenceOwnedType.GetChangeTrackingStrategy());
                    Assert.Null(referenceOwnedType.GetQueryFilter());
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.PropertyAccessMode]);
                    Assert.Null(referenceOwnedType[CoreAnnotationNames.NavigationAccessMode]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetPropertyAccessMode()).Message);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => referenceOwnedType.GetNavigationAccessMode()).Message);

                    var principalTable = StoreObjectIdentifier.Create(referenceOwnedType, StoreObjectType.Table).Value;

                    var ownedId = referenceOwnedType.FindProperty("PrincipalBaseId");
                    Assert.True(ownedId.IsPrimaryKey());

                    var detailsProperty = referenceOwnedType.FindProperty(nameof(OwnedType.Details));

                    var ownedFragment = referenceOwnedType.GetMappingFragments().Single();
                    Assert.Equal(nameof(OwnedType.Details), detailsProperty.GetColumnName(ownedFragment.StoreObject));
                    Assert.Null(detailsProperty.GetColumnName(principalTable));

                    var referenceOwnership = referenceOwnedNavigation.ForeignKey;
                    Assert.Empty(referenceOwnership.GetAnnotations());
                    Assert.Same(referenceOwnership, referenceOwnedType.FindOwnership());
                    Assert.True(referenceOwnership.IsOwnership);
                    Assert.True(referenceOwnership.IsRequired);
                    Assert.True(referenceOwnership.IsRequiredDependent);
                    Assert.True(referenceOwnership.IsUnique);
                    Assert.Null(referenceOwnership.DependentToPrincipal);
                    Assert.Same(referenceOwnedNavigation, referenceOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, referenceOwnership.DeleteBehavior);
                    Assert.Equal(2, referenceOwnership.Properties.Count());
                    Assert.Same(principalKey, referenceOwnership.PrincipalKey);

                    var ownedServiceProperty = referenceOwnedType.GetServiceProperties().Single();
                    Assert.Empty(ownedServiceProperty.GetAnnotations());
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.ClrType);
                    Assert.Equal(typeof(DbContext), ownedServiceProperty.PropertyInfo.PropertyType);
                    Assert.Null(ownedServiceProperty.FieldInfo);
                    Assert.Same(referenceOwnedType, ownedServiceProperty.DeclaringEntityType);
                    var ownedServicePropertyBinding = ownedServiceProperty.ParameterBinding;
                    Assert.IsType<ContextParameterBinding>(ownedServicePropertyBinding);
                    Assert.Equal(typeof(DbContext), ownedServicePropertyBinding.ServiceType);
                    Assert.Equal(ownedServiceProperty, ownedServicePropertyBinding.ConsumedProperties.Single());
                    Assert.Equal(PropertyAccessMode.PreferField, ownedServiceProperty.GetPropertyAccessMode());
                    Assert.Null(ownedServiceProperty[CoreAnnotationNames.PropertyAccessMode]);

                    var principalDerived = model.FindEntityType(typeof(PrincipalDerived<DependentBase<byte?>>));
                    Assert.Equal(principalBase, principalDerived.BaseType);
                    Assert.Equal(
                        "Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+"
                        + "PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.Internal.CSharpRuntimeModelCodeGeneratorTest+DependentBase<byte?>>",
                        principalDerived.Name);
                    Assert.False(principalDerived.IsOwned());
                    Assert.IsType<ConstructorBinding>(principalDerived.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, principalDerived.GetChangeTrackingStrategy());
                    Assert.Equal("PrincipalDerived<DependentBase<byte?>>", principalDerived.GetDiscriminatorValue());

                    var tptForeignKey = principalDerived.GetForeignKeys().Single();
                    Assert.False(tptForeignKey.IsOwnership);
                    Assert.True(tptForeignKey.IsRequired);
                    Assert.False(tptForeignKey.IsRequiredDependent);
                    Assert.True(tptForeignKey.IsUnique);
                    Assert.Null(tptForeignKey.DependentToPrincipal);
                    Assert.Null(tptForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, tptForeignKey.DeleteBehavior);
                    Assert.Equal(principalKey.Properties, tptForeignKey.Properties);
                    Assert.Same(principalKey, tptForeignKey.PrincipalKey);

                    Assert.Equal(2, principalDerived.GetDeclaredNavigations().Count());
                    var dependentNavigation = principalDerived.GetDeclaredNavigations().First();
                    Assert.Equal("Dependent", dependentNavigation.Name);
                    Assert.Equal("Dependent", dependentNavigation.PropertyInfo.Name);
                    Assert.Equal("<Dependent>k__BackingField", dependentNavigation.FieldInfo.Name);
                    Assert.False(dependentNavigation.IsCollection);
                    Assert.True(dependentNavigation.IsEagerLoaded);
                    Assert.False(dependentNavigation.LazyLoadingEnabled);
                    Assert.False(dependentNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, dependentNavigation.DeclaringEntityType);
                    Assert.Equal("Principal", dependentNavigation.Inverse.Name);

                    var ownedCollectionNavigation = principalDerived.GetDeclaredNavigations().Last();
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.Name);
                    Assert.Null(ownedCollectionNavigation.PropertyInfo);
                    Assert.Equal("ManyOwned", ownedCollectionNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<OwnedType>), ownedCollectionNavigation.ClrType);
                    Assert.True(ownedCollectionNavigation.IsCollection);
                    Assert.True(ownedCollectionNavigation.IsEagerLoaded);
                    Assert.False(ownedCollectionNavigation.IsOnDependent);
                    Assert.Null(ownedCollectionNavigation.Inverse);
                    Assert.Equal(principalDerived, ownedCollectionNavigation.DeclaringEntityType);

                    var collectionOwnedType = ownedCollectionNavigation.TargetEntityType;
                    Assert.Equal(principalDerived.Name + ".ManyOwned#OwnedType", collectionOwnedType.Name);
                    Assert.Equal(typeof(OwnedType), collectionOwnedType.ClrType);
                    Assert.True(collectionOwnedType.HasSharedClrType);
                    Assert.False(collectionOwnedType.IsPropertyBag);
                    Assert.True(collectionOwnedType.IsOwned());
                    Assert.Null(collectionOwnedType[RelationalAnnotationNames.IsTableExcludedFromMigrations]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => collectionOwnedType.IsTableExcludedFromMigrations()).Message);
                    Assert.Null(collectionOwnedType.BaseType);
                    Assert.IsType<ConstructorBinding>(collectionOwnedType.ConstructorBinding);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, collectionOwnedType.GetChangeTrackingStrategy());

                    var collectionOwnership = ownedCollectionNavigation.ForeignKey;
                    Assert.Same(collectionOwnership, collectionOwnedType.FindOwnership());
                    Assert.True(collectionOwnership.IsOwnership);
                    Assert.True(collectionOwnership.IsRequired);
                    Assert.False(collectionOwnership.IsRequiredDependent);
                    Assert.False(collectionOwnership.IsUnique);
                    Assert.Null(collectionOwnership.DependentToPrincipal);
                    Assert.Same(ownedCollectionNavigation, collectionOwnership.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.Cascade, collectionOwnership.DeleteBehavior);
                    Assert.Equal(2, collectionOwnership.Properties.Count());

                    var derivedSkipNavigation = principalDerived.GetDeclaredSkipNavigations().Single();
                    Assert.Equal("Principals", derivedSkipNavigation.Name);
                    Assert.Equal("Principals", derivedSkipNavigation.PropertyInfo.Name);
                    Assert.Equal("<Principals>k__BackingField", derivedSkipNavigation.FieldInfo.Name);
                    Assert.Equal(typeof(ICollection<PrincipalBase>), derivedSkipNavigation.ClrType);
                    Assert.True(derivedSkipNavigation.IsCollection);
                    Assert.True(derivedSkipNavigation.IsEagerLoaded);
                    Assert.False(derivedSkipNavigation.LazyLoadingEnabled);
                    Assert.False(derivedSkipNavigation.IsOnDependent);
                    Assert.Equal(principalDerived, derivedSkipNavigation.DeclaringEntityType);
                    Assert.Equal("Deriveds", derivedSkipNavigation.Inverse.Name);
                    Assert.Same(principalBase.GetSkipNavigations().Single(), derivedSkipNavigation.Inverse);

                    Assert.Same(derivedSkipNavigation, derivedSkipNavigation.ForeignKey.GetReferencingSkipNavigations().Single());
                    Assert.Same(
                        derivedSkipNavigation.Inverse, derivedSkipNavigation.Inverse.ForeignKey.GetReferencingSkipNavigations().Single());

                    Assert.Equal(new[] { derivedSkipNavigation.Inverse, derivedSkipNavigation }, principalDerived.GetSkipNavigations());

                    var joinType = derivedSkipNavigation.JoinEntityType;

                    Assert.Equal("PrincipalBasePrincipalDerived<DependentBase<byte?>>", joinType.Name);
                    Assert.Equal(typeof(Dictionary<string, object>), joinType.ClrType);
                    Assert.True(joinType.HasSharedClrType);
                    Assert.True(joinType.IsPropertyBag);
                    Assert.False(joinType.IsOwned());
                    Assert.Null(joinType.BaseType);
                    Assert.IsType<ConstructorBinding>(joinType.ConstructorBinding);
                    Assert.Equal("Item", joinType.FindIndexerPropertyInfo().Name);
                    Assert.Equal(ChangeTrackingStrategy.Snapshot, joinType.GetChangeTrackingStrategy());
                    Assert.Null(joinType[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => joinType.GetComment()).Message);
                    Assert.Null(joinType.GetQueryFilter());

                    var rowid = joinType.GetProperties().Single(p => !p.IsForeignKey());
                    Assert.Equal(typeof(byte[]), rowid.ClrType);
                    Assert.True(rowid.IsIndexerProperty());
                    Assert.Same(joinType.FindIndexerPropertyInfo(), rowid.PropertyInfo);
                    Assert.Null(rowid.FieldInfo);
                    Assert.True(rowid.IsNullable);
                    Assert.False(rowid.IsShadowProperty());
                    Assert.True(rowid.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.OnAddOrUpdate, rowid.ValueGenerated);
                    Assert.Equal("rowid", rowid.GetColumnName());
                    Assert.Equal("BLOB", rowid.GetColumnType());
                    Assert.Null(rowid[RelationalAnnotationNames.Comment]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetComment()).Message);
                    Assert.Null(rowid[RelationalAnnotationNames.ColumnOrder]);
                    Assert.Equal(
                        CoreStrings.RuntimeModelMissingData,
                        Assert.Throws<InvalidOperationException>(() => rowid.GetColumnOrder()).Message);
                    Assert.Null(rowid.GetValueConverter());
                    Assert.NotNull(rowid.GetValueComparer());
                    Assert.NotNull(rowid.GetKeyValueComparer());

                    var dependentForeignKey = dependentNavigation.ForeignKey;
                    Assert.False(dependentForeignKey.IsOwnership);
                    Assert.True(dependentForeignKey.IsRequired);
                    Assert.False(dependentForeignKey.IsRequiredDependent);
                    Assert.True(dependentForeignKey.IsUnique);
                    Assert.Same(dependentNavigation.Inverse, dependentForeignKey.DependentToPrincipal);
                    Assert.Same(dependentNavigation, dependentForeignKey.PrincipalToDependent);
                    Assert.Equal(DeleteBehavior.ClientNoAction, dependentForeignKey.DeleteBehavior);
                    Assert.Equal(new[] { "PrincipalId", "PrincipalAlternateId" }, dependentForeignKey.Properties.Select(p => p.Name));
                    Assert.Same(principalKey, dependentForeignKey.PrincipalKey);

                    var dependentBase = dependentNavigation.TargetEntityType;

                    Assert.False(dependentBase.GetIsDiscriminatorMappingComplete());
                    var principalDiscriminator = dependentBase.FindDiscriminatorProperty();
                    Assert.IsType<DiscriminatorValueGenerator>(
                        principalDiscriminator.GetValueGeneratorFactory()(principalDiscriminator, dependentBase));
                    Assert.Equal(Enum1.One, dependentBase.GetDiscriminatorValue());

                    var dependentBaseForeignKey = dependentBase.GetForeignKeys().Single(fk => fk != dependentForeignKey);
                    var dependentForeignKeyProperty = dependentBaseForeignKey.Properties.Single();

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, dependentForeignKey }, dependentForeignKeyProperty.GetContainingForeignKeys());

                    var dependentDerived = dependentBase.GetDerivedTypes().Single();
                    Assert.Equal(Enum1.Two, dependentDerived.GetDiscriminatorValue());

                    Assert.Equal(2, dependentDerived.GetDeclaredProperties().Count());

                    var dependentData = dependentDerived.GetDeclaredProperties().First();
                    Assert.Equal(typeof(string), dependentData.ClrType);
                    Assert.Equal("Data", dependentData.Name);
                    Assert.Equal("Data", dependentData.PropertyInfo.Name);
                    Assert.Equal("<Data>k__BackingField", dependentData.FieldInfo.Name);
                    Assert.True(dependentData.IsNullable);
                    Assert.False(dependentData.IsShadowProperty());
                    Assert.False(dependentData.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentData.ValueGenerated);
                    Assert.Equal("Data", dependentData.GetColumnName());
                    Assert.Equal("TEXT", dependentData.GetColumnType());
                    Assert.Equal(20, dependentData.GetMaxLength());
                    Assert.False(dependentData.IsUnicode());
                    Assert.True(dependentData.IsFixedLength());
                    Assert.Null(dependentData.GetPrecision());
                    Assert.Null(dependentData.GetScale());

                    var dependentMoney = dependentDerived.GetDeclaredProperties().Last();
                    Assert.Equal(typeof(decimal), dependentMoney.ClrType);
                    Assert.Equal("Money", dependentMoney.Name);
                    Assert.Null(dependentMoney.PropertyInfo);
                    Assert.Null(dependentMoney.FieldInfo);
                    Assert.False(dependentMoney.IsNullable);
                    Assert.True(dependentMoney.IsShadowProperty());
                    Assert.False(dependentMoney.IsConcurrencyToken);
                    Assert.Equal(ValueGenerated.Never, dependentMoney.ValueGenerated);
                    Assert.Equal("Money", dependentMoney.GetColumnName());
                    Assert.Equal("TEXT", dependentMoney.GetColumnType());
                    Assert.Null(dependentMoney.GetMaxLength());
                    Assert.Null(dependentMoney.IsUnicode());
                    Assert.Null(dependentMoney.IsFixedLength());
                    Assert.Equal(9, dependentMoney.GetPrecision());
                    Assert.Equal(3, dependentMoney.GetScale());

                    Assert.Equal(
                        new[]
                        {
                            derivedSkipNavigation.ForeignKey,
                            tptForeignKey,
                            referenceOwnership,
                            collectionOwnership,
                            dependentForeignKey,
                            derivedSkipNavigation.Inverse.ForeignKey
                        },
                        principalKey.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { dependentBaseForeignKey, tptForeignKey, referenceOwnership, derivedSkipNavigation.Inverse.ForeignKey },
                        principalBase.GetReferencingForeignKeys());

                    Assert.Equal(
                        new[] { derivedSkipNavigation.ForeignKey, collectionOwnership, dependentForeignKey },
                        principalDerived.GetDeclaredReferencingForeignKeys());

                    Assert.Equal(
                        new[]
                        {
                            dataEntity,
                            dependentBase,
                            dependentDerived,
                            manyTypesType,
                            principalBase,
                            referenceOwnedType,
                            principalDerived,
                            collectionOwnedType,
                            joinType
                        },
                        model.GetEntityTypes());
                },
                typeof(SqliteNetTopologySuiteDesignTimeServices));

        public class SqliteContext : DbContext
        {
            private readonly bool _jsonColumns;

            public SqliteContext(bool jsonColumns = false)
            {
                _jsonColumns = jsonColumns;
            }

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseSqlite(o => o.UseNetTopologySuite());

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
                modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

                modelBuilder.Entity<Data>(
                    eb =>
                    {
                        eb.Property<int>("Id");
                        eb.HasKey("Id");

                        eb.Property<Point>("Point")
                            .HasSrid(1101);
                    });

                modelBuilder.Entity<PrincipalBase>(
                    eb =>
                    {
                        if (!_jsonColumns)
                        {
                            eb.Property(e => e.Id).Metadata.SetColumnName("DerivedId", StoreObjectIdentifier.Table("PrincipalDerived"));
                        }

                        eb.Property(e => e.FlagsEnum2)
                            .HasSentinel(AFlagsEnum.C | AFlagsEnum.B);

                        eb.Property(e => e.AlternateId)
                            .UsePropertyAccessMode(PropertyAccessMode.FieldDuringConstruction);

                        eb.Property<Point>("Point")
                            .HasColumnType("geometry")
                            .HasDefaultValue(
                                NtsGeometryServices.Instance.CreateGeometryFactory(srid: 0).CreatePoint(new CoordinateZM(0, 0, 0, 0)))
                            .HasConversion<CastingConverter<Point, Point>, CustomValueComparer<Point>, CustomValueComparer<Point>>();

                        eb.HasIndex(e => new { e.AlternateId, e.Id });

                        eb.HasKey(e => new { e.Id, e.AlternateId })
                            .HasName("PK");

                        eb.HasAlternateKey(e => e.Id);

                        eb.Property(e => e.AlternateId).Metadata.SetJsonValueReaderWriterType(
                            _jsonColumns
                                ? typeof(MyJsonGuidReaderWriter)
                                : typeof(JsonGuidReaderWriter));

                        eb.OwnsOne(
                            e => e.Owned, ob =>
                            {
                                ob.HasChangeTrackingStrategy(ChangeTrackingStrategy.ChangingAndChangedNotificationsWithOriginalValues);
                                ob.UsePropertyAccessMode(PropertyAccessMode.Field);
                                ob.Property(e => e.Details);

                                if (_jsonColumns)
                                {
                                    ob.ToJson();
                                }
                                else
                                {

                                    ob.SplitToTable("Details", s => s.Property(e => e.Details));

                                    ob.HasData(
                                        new
                                        {
                                            Number = 10,
                                            PrincipalBaseId = 1L,
                                            PrincipalBaseAlternateId = new Guid()
                                        });
                                }
                            });

                        eb.Navigation(e => e.Owned).IsRequired().HasField("_ownedField")
                            .UsePropertyAccessMode(PropertyAccessMode.Field);

                        if (!_jsonColumns)
                        {
                            eb.HasData(new PrincipalBase { Id = 1, AlternateId = new Guid() });

                            eb.ToTable("PrincipalBase", "mySchema");
                        }
                    });

                modelBuilder.Entity<PrincipalDerived<DependentBase<byte?>>>(
                    eb =>
                    {
                        eb.HasOne(e => e.Dependent).WithOne(e => e.Principal)
                            .HasForeignKey<DependentBase<byte?>>()
                            .OnDelete(DeleteBehavior.ClientNoAction);

                        eb.Navigation(e => e.Dependent).AutoInclude().EnableLazyLoading(false);

                        eb.OwnsMany(
                            typeof(OwnedType).FullName, "ManyOwned", ob =>
                            {
                                if (_jsonColumns)
                                {
                                    ob.ToJson();
                                }
                            });

                        eb.HasMany(e => e.Principals).WithMany(e => (ICollection<PrincipalDerived<DependentBase<byte?>>>)e.Deriveds)
                            .UsingEntity(
                                jb =>
                                {
                                    jb.ToTable(tb => tb.HasComment("Join table"));
                                    jb.Property<byte[]>("rowid")
                                        .IsRowVersion()
                                        .HasComment("RowVersion")
                                        .HasColumnOrder(1);
                                });

                        eb.Navigation(e => e.Principals).AutoInclude().EnableLazyLoading(false);

                        if (!_jsonColumns)
                        {
                            eb.ToTable("PrincipalDerived");
                        }
                    });

                modelBuilder.Entity<DependentBase<byte?>>(
                    eb =>
                    {
                        eb.Property<byte?>("Id");

                        eb.HasKey("PrincipalId", "PrincipalAlternateId");

                        eb.HasOne<PrincipalBase>().WithOne()
                            .HasForeignKey<DependentBase<byte?>>("PrincipalId")
                            .HasPrincipalKey<PrincipalBase>(e => e.Id);

                        eb.HasDiscriminator<Enum1>("EnumDiscriminator")
                            .HasValue(Enum1.One)
                            .HasValue<DependentDerived<byte?>>(Enum1.Two)
                            .IsComplete(false);
                    });

                modelBuilder.Entity<DependentDerived<byte?>>(
                    eb =>
                    {
                        eb.Property<string>("Data")
                            .HasMaxLength(20)
                            .IsFixedLength()
                            .IsUnicode(false);

                        eb.Property<decimal>("Money")
                            .HasPrecision(9, 3);
                    });

                modelBuilder.Entity<ManyTypes>(
                    b =>
                    {
                        b.Property(e => e.Id).HasConversion<ManyTypesIdConverter>().ValueGeneratedOnAdd();
                        b.HasKey(e => e.Id);

                        b.Property(e => e.Enum8AsString).HasConversion<string>();
                        b.Property(e => e.Enum16AsString).HasConversion<string>();
                        b.Property(e => e.Enum32AsString).HasConversion<string>();
                        b.Property(e => e.Enum64AsString).HasConversion<string>();
                        b.Property(e => e.EnumU8AsString).HasConversion<string>();
                        b.Property(e => e.EnumU16AsString).HasConversion<string>();
                        b.Property(e => e.EnumU32AsString).HasConversion<string>();
                        b.Property(e => e.EnumU64AsString).HasConversion<string>();

                        b.PrimitiveCollection(e => e.Enum8AsStringCollection).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.Enum16AsStringCollection).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.Enum32AsStringCollection).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.Enum64AsStringCollection).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU8AsStringCollection).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU16AsStringCollection).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU32AsStringCollection).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU64AsStringCollection).ElementType(b => b.HasConversion<string>());

                        b.PrimitiveCollection(e => e.Enum8AsStringArray).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.Enum16AsStringArray).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.Enum32AsStringArray).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.Enum64AsStringArray).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU8AsStringArray).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU16AsStringArray).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU32AsStringArray).ElementType(b => b.HasConversion<string>());
                        b.PrimitiveCollection(e => e.EnumU64AsStringArray).ElementType(b => b.HasConversion<string>());

                        b.Property(e => e.BoolToStringConverterProperty).HasConversion(new BoolToStringConverter("A", "B"));
                        b.Property(e => e.BoolToTwoValuesConverterProperty).HasConversion(new BoolToTwoValuesConverter<byte>(0, 1));
                        b.Property(e => e.BoolToZeroOneConverterProperty).HasConversion<BoolToZeroOneConverter<short>>();
                        b.Property(e => e.BytesToStringConverterProperty).HasConversion<BytesToStringConverter>();
                        b.Property(e => e.CastingConverterProperty).HasConversion<CastingConverter<int, decimal>>();
                        b.Property(e => e.CharToStringConverterProperty).HasConversion<CharToStringConverter>();
                        b.Property(e => e.DateOnlyToStringConverterProperty).HasConversion<DateOnlyToStringConverter>();
                        b.Property(e => e.DateTimeOffsetToBinaryConverterProperty).HasConversion<DateTimeOffsetToBinaryConverter>();
                        b.Property(e => e.DateTimeOffsetToBytesConverterProperty).HasConversion<DateTimeOffsetToBytesConverter>();
                        b.Property(e => e.DateTimeOffsetToStringConverterProperty).HasConversion<DateTimeOffsetToStringConverter>();
                        b.Property(e => e.DateTimeToBinaryConverterProperty).HasConversion<DateTimeToBinaryConverter>();
                        b.Property(e => e.DateTimeToStringConverterProperty).HasConversion<DateTimeToStringConverter>();
                        b.Property(e => e.EnumToNumberConverterProperty).HasConversion<EnumToNumberConverter<Enum32, int>>();
                        b.Property(e => e.EnumToStringConverterProperty).HasConversion<EnumToStringConverter<Enum32>>();
                        b.Property(e => e.GuidToBytesConverterProperty).HasConversion<GuidToBytesConverter>();
                        b.Property(e => e.GuidToStringConverterProperty).HasConversion<GuidToStringConverter>();
                        b.Property(e => e.IPAddressToBytesConverterProperty).HasConversion<IPAddressToBytesConverter>();
                        b.Property(e => e.IPAddressToStringConverterProperty).HasConversion<IPAddressToStringConverter>();
                        b.Property(e => e.IntNumberToBytesConverterProperty).HasConversion<NumberToBytesConverter<int>>();
                        b.Property(e => e.DecimalNumberToBytesConverterProperty).HasConversion<NumberToBytesConverter<decimal>>();
                        b.Property(e => e.DoubleNumberToBytesConverterProperty).HasConversion<NumberToBytesConverter<double>>();
                        b.Property(e => e.IntNumberToStringConverterProperty).HasConversion<NumberToStringConverter<int>>();
                        b.Property(e => e.DecimalNumberToStringConverterProperty).HasConversion<NumberToStringConverter<decimal>>();
                        b.Property(e => e.DoubleNumberToStringConverterProperty).HasConversion<NumberToStringConverter<double>>();
                        b.Property(e => e.PhysicalAddressToBytesConverterProperty).HasConversion<PhysicalAddressToBytesConverter>();
                        b.Property(e => e.PhysicalAddressToStringConverterProperty).HasConversion<PhysicalAddressToStringConverter>();
                        b.Property(e => e.StringToBoolConverterProperty).HasConversion<StringToBoolConverter>();
                        b.Property(e => e.StringToBytesConverterProperty).HasConversion(new StringToBytesConverter(Encoding.UTF32));
                        b.Property(e => e.StringToCharConverterProperty).HasConversion<StringToCharConverter>();
                        b.Property(e => e.StringToDateOnlyConverterProperty).HasConversion<StringToDateOnlyConverter>();
                        b.Property(e => e.StringToDateTimeConverterProperty).HasConversion<StringToDateTimeConverter>();
                        b.Property(e => e.StringToDateTimeOffsetConverterProperty).HasConversion<StringToDateTimeOffsetConverter>();
                        b.Property(e => e.StringToEnumConverterProperty).HasConversion<StringToEnumConverter<EnumU32>>();
                        b.Property(e => e.StringToIntNumberConverterProperty).HasConversion<StringToNumberConverter<int>>();
                        b.Property(e => e.StringToDecimalNumberConverterProperty).HasConversion<StringToNumberConverter<decimal>>();
                        b.Property(e => e.StringToDoubleNumberConverterProperty).HasConversion<StringToNumberConverter<double>>();
                        b.Property(e => e.StringToTimeOnlyConverterProperty).HasConversion<StringToTimeOnlyConverter>();
                        b.Property(e => e.StringToTimeSpanConverterProperty).HasConversion<StringToTimeSpanConverter>();
                        b.Property(e => e.StringToUriConverterProperty).HasConversion<StringToUriConverter>();
                        b.Property(e => e.TimeOnlyToStringConverterProperty).HasConversion<TimeOnlyToStringConverter>();
                        b.Property(e => e.TimeOnlyToTicksConverterProperty).HasConversion<TimeOnlyToTicksConverter>();
                        b.Property(e => e.TimeSpanToStringConverterProperty).HasConversion<TimeSpanToStringConverter>();
                        b.Property(e => e.TimeSpanToTicksConverterProperty).HasConversion<TimeSpanToTicksConverter>();
                        b.Property(e => e.UriToStringConverterProperty).HasConversion<UriToStringConverter>();
                        b.Property(e => e.NullIntToNullStringConverterProperty).HasConversion<NullIntToNullStringConverter>();
                    });
            }
        }

        public class NullIntToNullStringConverter : ValueConverter<int?, string>
        {
            public NullIntToNullStringConverter()
                : base(v => v == null ? null : v.ToString()!, v => v == null || v == "<null>" ? null : int.Parse(v), convertsNulls: true)
            {
            }
        }

        public class Data
        {
            public byte[] Blob { get; set; }
        }

        public abstract class ContextBase : DbContext
        {
            protected override void OnModelCreating(ModelBuilder modelBuilder)
                => modelBuilder.Model.RemoveAnnotation(CoreAnnotationNames.ProductVersion);

            protected override void OnConfiguring(DbContextOptionsBuilder options)
                => options
                    .EnableServiceProviderCaching(false)
                    .UseInMemoryDatabase(nameof(CSharpRuntimeModelCodeGeneratorTest));
        }


        protected void Test(
            DbContext context,
            CompiledModelCodeGenerationOptions options,
            Action<IReadOnlyCollection<ScaffoldedFile>> assertScaffold = null,
            Action<IModel> assertModel = null,
            Type additionalDesignTimeServices = null,
            Action<DbContext> useContext = null,
            string expectedExceptionMessage = null)
        {
            var model = context.GetService<IDesignTimeModel>().Model;

            options.ModelNamespace ??= "TestNamespace";
            options.ContextType = context.GetType();

            var generator = DesignTestHelpers.Instance.CreateDesignServiceProvider(
                    context.GetService<IDatabaseProvider>().Name,
                    additionalDesignTimeServices: additionalDesignTimeServices)
                .GetRequiredService<ICompiledModelCodeGeneratorSelector>()
                .Select(options);

            if (expectedExceptionMessage != null)
            {
                Assert.Equal(
                    expectedExceptionMessage,
                    Assert.Throws<InvalidOperationException>(
                        () => generator.GenerateModel(
                            model,
                            options)).Message);
                return;
            }

            var scaffoldedFiles = generator.GenerateModel(
                model,
                options);

            var build = new BuildSource
            {
                References =
                {
                    BuildReference.ByName("System.Linq"),
                    BuildReference.ByName("System.Net.Primitives"),
                    BuildReference.ByName("System.Net.NetworkInformation"),
                    BuildReference.ByName("System.Threading.Thread"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Abstractions"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.InMemory"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Proxies"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Relational"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Sqlite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Sqlite.NetTopologySuite"),
                    BuildReference.ByName("Microsoft.EntityFrameworkCore.Specification.Tests"),
                    BuildReference.ByName("NetTopologySuite"),
                    BuildReference.ByName("Newtonsoft.Json"),
                    BuildReference.ByName(typeof(CSharpRuntimeModelCodeGeneratorTest).Assembly.GetName().Name)
                },
                Sources = scaffoldedFiles.ToDictionary(f => f.Path, f => f.Code),
                NullableReferenceTypes = options.UseNullableReferenceTypes
            };

            var assembly = build.BuildInMemory();

            var modelTypeName = options.ContextType.Name + "Model";
            var modelType = assembly.GetType(
                string.IsNullOrEmpty(options.ModelNamespace)
                    ? modelTypeName
                    : options.ModelNamespace + "." + modelTypeName);
            var instancePropertyInfo = modelType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
            var compiledModel = (IModel)instancePropertyInfo.GetValue(null);

            var modelRuntimeInitializer = context.GetService<IModelRuntimeInitializer>();
            compiledModel = modelRuntimeInitializer.Initialize(compiledModel, designTime: false);
            assertModel(compiledModel);

            var relationalModel = (IRelationalModel)context.Model.FindRuntimeAnnotationValue(RelationalAnnotationNames.RelationalModel);
            if (relationalModel != null)
            {
                RelationalModelTest.AssertEqual(relationalModel, compiledModel.GetRelationalModel());
            }

            if (assertScaffold != null)
            {
                AssertBaseline(scaffoldedFiles, assertScaffold);
            }

        }

        private const string FileNewLine = @"
";

        private static readonly object _baselineFileLock = new();

        private static void AssertBaseline(
            IReadOnlyCollection<ScaffoldedFile> scaffoldedFiles,
            Action<IReadOnlyCollection<ScaffoldedFile>> assertScaffold)
        {
            try
            {
                assertScaffold(scaffoldedFiles);
            }
            catch
            {
                var methodCallLine = Environment.StackTrace.Split(
                    new[] { Environment.NewLine },
                    StringSplitOptions.RemoveEmptyEntries)[3][6..];

                var indexMethodEnding = methodCallLine.IndexOf(')') + 1;
                var testName = methodCallLine[..indexMethodEnding];
                var parts = methodCallLine[indexMethodEnding..].Split(" ", StringSplitOptions.RemoveEmptyEntries);
                var fileName = parts[1][..^5];
                var lineNumber = int.Parse(parts[2]);

                var currentDirectory = Directory.GetCurrentDirectory();
                var logFile = currentDirectory[..(currentDirectory.LastIndexOf(
                            $"{Path.DirectorySeparatorChar}artifacts{Path.DirectorySeparatorChar}",
                            StringComparison.Ordinal)
                        + 1)]
                    + "RuntimeModelBaseline.txt";

                var testInfo = testName + " : " + lineNumber + FileNewLine;

                var baselines = string.Join(
                    "," + FileNewLine,
                    scaffoldedFiles.Select(
                        file =>
                            Indent(5)
                            + "c => AssertFileContents("
                            + FileNewLine
                            + Indent(6)
                            + $"\"{file.Path}\","
                            + FileNewLine
                            + Indent(6)
                            + "\"\"\""
                            + FileNewLine
                            + file.Code.TrimEnd()
                            + FileNewLine
                            + "\"\"\", c)"));

                var testString = @$"
{Indent(4)}code => Assert.Collection(
{Indent(5)}code,
{baselines}),
";

                var contents = testInfo + testString;

                lock (_baselineFileLock)
                {
                    File.Delete(logFile);
                    File.AppendAllText(logFile, contents);
                }

                throw;
            }

            static string Indent(int indent)
                => new(' ', indent * 4);
        }

        protected static void AssertFileContents(
            string expectedPath,
            string expectedCode,
            ScaffoldedFile file)
        {
            Assert.Equal(expectedPath, file.Path);
            Assert.Equal(expectedCode, file.Code.TrimEnd(), ignoreLineEndingDifferences: true);
        }
    }

    public class Internal
    {
        public long Id { get; set; }
    }

    public class Index
    {
        public Guid Id { get; set; }
    }

    public class IdentityUser : TestModels.AspNetIdentity.IdentityUser
    {
    }

    public class SelfReferentialEntity
    {
        public long Id { get; set; }

        public SelfReferentialProperty Collection { get; set; }
    }

    public class SelfReferentialProperty : List<SelfReferentialProperty>
    {
    }
}

namespace Microsoft.EntityFrameworkCore.Scaffolding.TestModel.Internal
{
    public class DbContext : ContextBase
    {
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Index>();
            modelBuilder.Entity<IdentityUser>();
            modelBuilder.Entity<Scaffolding.Internal.IdentityUser>(
                eb =>
                {
                    eb.HasDiscriminator().HasValue("DerivedIdentityUser");
                });
            modelBuilder.Entity<Scaffolding.Internal.Internal>();
        }
    }

    public class SelfReferentialDbContext : ContextBase
    {
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<SelfReferentialEntity>(
                eb =>
                {
                    eb.Property(e => e.Collection).HasConversion(typeof(SelfReferentialPropertyValueConverter));
                });
        }
    }

    public class SelfReferentialPropertyValueConverter : ValueConverter<SelfReferentialProperty, string>
    {
        public SelfReferentialPropertyValueConverter()
            : this(null)
        {
        }

        public SelfReferentialPropertyValueConverter(ConverterMappingHints hints)
            : base(v => null, v => null, hints)
        {
        }
    }
}
